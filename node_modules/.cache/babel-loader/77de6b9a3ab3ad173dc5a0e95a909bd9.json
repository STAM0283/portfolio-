{"ast":null,"code":"var utils = require('./utils'),\n    lexer = require('./lexer');\n\nvar _t = lexer.types,\n    _reserved = ['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with'];\n/**\n * Filters are simply functions that perform transformations on their first input argument.\n * Filters are run at render time, so they may not directly modify the compiled template structure in any way.\n * All of Swig's built-in filters are written in this same way. For more examples, reference the `filters.js` file in Swig's source.\n *\n * To disable auto-escaping on a custom filter, simply add a property to the filter method `safe = true;` and the output from this will not be escaped, no matter what the global settings are for Swig.\n *\n * @typedef {function} Filter\n *\n * @example\n * // This filter will return 'bazbop' if the idx on the input is not 'foobar'\n * swig.setFilter('foobar', function (input, idx) {\n *   return input[idx] === 'foobar' ? input[idx] : 'bazbop';\n * });\n * // myvar = ['foo', 'bar', 'baz', 'bop'];\n * // => {{ myvar|foobar(3) }}\n * // Since myvar[3] !== 'foobar', we render:\n * // => bazbop\n *\n * @example\n * // This filter will disable auto-escaping on its output:\n * function bazbop (input) { return input; }\n * bazbop.safe = true;\n * swig.setFilter('bazbop', bazbop);\n * // => {{ \"<p>\"|bazbop }}\n * // => <p>\n *\n * @param {*} input Input argument, automatically sent from Swig's built-in parser.\n * @param {...*} [args] All other arguments are defined by the Filter author.\n * @return {*}\n */\n\n/*!\n * Makes a string safe for a regular expression.\n * @param  {string} str\n * @return {string}\n * @private\n */\n\nfunction escapeRegExp(str) {\n  return str.replace(/[\\-\\/\\\\\\^$*+?.()|\\[\\]{}]/g, '\\\\$&');\n}\n/**\n * Parse strings of variables and tags into tokens for future compilation.\n * @class\n * @param {array}   tokens     Pre-split tokens read by the Lexer.\n * @param {object}  filters    Keyed object of filters that may be applied to variables.\n * @param {boolean} autoescape Whether or not this should be autoescaped.\n * @param {number}  line       Beginning line number for the first token.\n * @param {string}  [filename] Name of the file being parsed.\n * @private\n */\n\n\nfunction TokenParser(tokens, filters, autoescape, line, filename) {\n  this.out = [];\n  this.state = [];\n  this.filterApplyIdx = [];\n  this._parsers = {};\n  this.line = line;\n  this.filename = filename;\n  this.filters = filters;\n  this.escape = autoescape;\n\n  this.parse = function () {\n    var self = this;\n\n    if (self._parsers.start) {\n      self._parsers.start.call(self);\n    }\n\n    utils.each(tokens, function (token, i) {\n      var prevToken = tokens[i - 1];\n      self.isLast = i === tokens.length - 1;\n\n      if (prevToken) {\n        while (prevToken.type === _t.WHITESPACE) {\n          i -= 1;\n          prevToken = tokens[i - 1];\n        }\n      }\n\n      self.prevToken = prevToken;\n      self.parseToken(token);\n    });\n\n    if (self._parsers.end) {\n      self._parsers.end.call(self);\n    }\n\n    if (self.escape) {\n      self.filterApplyIdx = [0];\n\n      if (typeof self.escape === 'string') {\n        self.parseToken({\n          type: _t.FILTER,\n          match: 'e'\n        });\n        self.parseToken({\n          type: _t.COMMA,\n          match: ','\n        });\n        self.parseToken({\n          type: _t.STRING,\n          match: String(autoescape)\n        });\n        self.parseToken({\n          type: _t.PARENCLOSE,\n          match: ')'\n        });\n      } else {\n        self.parseToken({\n          type: _t.FILTEREMPTY,\n          match: 'e'\n        });\n      }\n    }\n\n    return self.out;\n  };\n}\n\nTokenParser.prototype = {\n  /**\n   * Set a custom method to be called when a token type is found.\n   *\n   * @example\n   * parser.on(types.STRING, function (token) {\n   *   this.out.push(token.match);\n   * });\n   * @example\n   * parser.on('start', function () {\n   *   this.out.push('something at the beginning of your args')\n   * });\n   * parser.on('end', function () {\n   *   this.out.push('something at the end of your args');\n   * });\n   *\n   * @param  {number}   type Token type ID. Found in the Lexer.\n   * @param  {Function} fn   Callback function. Return true to continue executing the default parsing function.\n   * @return {undefined}\n   */\n  on: function (type, fn) {\n    this._parsers[type] = fn;\n  },\n\n  /**\n   * Parse a single token.\n   * @param  {{match: string, type: number, line: number}} token Lexer token object.\n   * @return {undefined}\n   * @private\n   */\n  parseToken: function (token) {\n    var self = this,\n        fn = self._parsers[token.type] || self._parsers['*'],\n        match = token.match,\n        prevToken = self.prevToken,\n        prevTokenType = prevToken ? prevToken.type : null,\n        lastState = self.state.length ? self.state[self.state.length - 1] : null,\n        temp;\n\n    if (fn && typeof fn === 'function') {\n      if (!fn.call(this, token)) {\n        return;\n      }\n    }\n\n    if (lastState && prevToken && lastState === _t.FILTER && prevTokenType === _t.FILTER && token.type !== _t.PARENCLOSE && token.type !== _t.COMMA && token.type !== _t.OPERATOR && token.type !== _t.FILTER && token.type !== _t.FILTEREMPTY) {\n      self.out.push(', ');\n    }\n\n    if (lastState && lastState === _t.METHODOPEN) {\n      self.state.pop();\n\n      if (token.type !== _t.PARENCLOSE) {\n        self.out.push(', ');\n      }\n    }\n\n    switch (token.type) {\n      case _t.WHITESPACE:\n        break;\n\n      case _t.STRING:\n        self.filterApplyIdx.push(self.out.length);\n        self.out.push(match.replace(/\\\\/g, '\\\\\\\\'));\n        break;\n\n      case _t.NUMBER:\n      case _t.BOOL:\n        self.filterApplyIdx.push(self.out.length);\n        self.out.push(match);\n        break;\n\n      case _t.FILTER:\n        if (!self.filters.hasOwnProperty(match) || typeof self.filters[match] !== \"function\") {\n          utils.throwError('Invalid filter \"' + match + '\"', self.line, self.filename);\n        }\n\n        self.escape = self.filters[match].safe ? false : self.escape;\n        self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '_filters[\"' + match + '\"](');\n        self.state.push(token.type);\n        break;\n\n      case _t.FILTEREMPTY:\n        if (!self.filters.hasOwnProperty(match) || typeof self.filters[match] !== \"function\") {\n          utils.throwError('Invalid filter \"' + match + '\"', self.line, self.filename);\n        }\n\n        self.escape = self.filters[match].safe ? false : self.escape;\n        self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '_filters[\"' + match + '\"](');\n        self.out.push(')');\n        break;\n\n      case _t.FUNCTION:\n      case _t.FUNCTIONEMPTY:\n        self.out.push('((typeof _ctx.' + match + ' !== \"undefined\") ? _ctx.' + match + ' : ((typeof ' + match + ' !== \"undefined\") ? ' + match + ' : _fn))(');\n        self.escape = false;\n\n        if (token.type === _t.FUNCTIONEMPTY) {\n          self.out[self.out.length - 1] = self.out[self.out.length - 1] + ')';\n        } else {\n          self.state.push(token.type);\n        }\n\n        self.filterApplyIdx.push(self.out.length - 1);\n        break;\n\n      case _t.PARENOPEN:\n        self.state.push(token.type);\n\n        if (self.filterApplyIdx.length) {\n          self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '(');\n\n          if (prevToken && prevTokenType === _t.VAR) {\n            temp = prevToken.match.split('.').slice(0, -1);\n            self.out.push(' || _fn).call(' + self.checkMatch(temp));\n            self.state.push(_t.METHODOPEN);\n            self.escape = false;\n          } else {\n            self.out.push(' || _fn)(');\n          }\n\n          self.filterApplyIdx.push(self.out.length - 3);\n        } else {\n          self.out.push('(');\n          self.filterApplyIdx.push(self.out.length - 1);\n        }\n\n        break;\n\n      case _t.PARENCLOSE:\n        temp = self.state.pop();\n\n        if (temp !== _t.PARENOPEN && temp !== _t.FUNCTION && temp !== _t.FILTER) {\n          utils.throwError('Mismatched nesting state', self.line, self.filename);\n        }\n\n        self.out.push(')'); // Once off the previous entry\n\n        self.filterApplyIdx.pop();\n\n        if (temp !== _t.FILTER) {\n          // Once for the open paren\n          self.filterApplyIdx.pop();\n        }\n\n        break;\n\n      case _t.COMMA:\n        if (lastState !== _t.FUNCTION && lastState !== _t.FILTER && lastState !== _t.ARRAYOPEN && lastState !== _t.CURLYOPEN && lastState !== _t.PARENOPEN && lastState !== _t.COLON) {\n          utils.throwError('Unexpected comma', self.line, self.filename);\n        }\n\n        if (lastState === _t.COLON) {\n          self.state.pop();\n        }\n\n        self.out.push(', ');\n        self.filterApplyIdx.pop();\n        break;\n\n      case _t.LOGIC:\n      case _t.COMPARATOR:\n        if (!prevToken || prevTokenType === _t.COMMA || prevTokenType === token.type || prevTokenType === _t.BRACKETOPEN || prevTokenType === _t.CURLYOPEN || prevTokenType === _t.PARENOPEN || prevTokenType === _t.FUNCTION) {\n          utils.throwError('Unexpected logic', self.line, self.filename);\n        }\n\n        self.out.push(token.match);\n        break;\n\n      case _t.NOT:\n        self.out.push(token.match);\n        break;\n\n      case _t.VAR:\n        self.parseVar(token, match, lastState);\n        break;\n\n      case _t.BRACKETOPEN:\n        if (!prevToken || prevTokenType !== _t.VAR && prevTokenType !== _t.BRACKETCLOSE && prevTokenType !== _t.PARENCLOSE) {\n          self.state.push(_t.ARRAYOPEN);\n          self.filterApplyIdx.push(self.out.length);\n        } else {\n          self.state.push(token.type);\n        }\n\n        self.out.push('[');\n        break;\n\n      case _t.BRACKETCLOSE:\n        temp = self.state.pop();\n\n        if (temp !== _t.BRACKETOPEN && temp !== _t.ARRAYOPEN) {\n          utils.throwError('Unexpected closing square bracket', self.line, self.filename);\n        }\n\n        self.out.push(']');\n        self.filterApplyIdx.pop();\n        break;\n\n      case _t.CURLYOPEN:\n        self.state.push(token.type);\n        self.out.push('{');\n        self.filterApplyIdx.push(self.out.length - 1);\n        break;\n\n      case _t.COLON:\n        if (lastState !== _t.CURLYOPEN) {\n          utils.throwError('Unexpected colon', self.line, self.filename);\n        }\n\n        self.state.push(token.type);\n        self.out.push(':');\n        self.filterApplyIdx.pop();\n        break;\n\n      case _t.CURLYCLOSE:\n        if (lastState === _t.COLON) {\n          self.state.pop();\n        }\n\n        if (self.state.pop() !== _t.CURLYOPEN) {\n          utils.throwError('Unexpected closing curly brace', self.line, self.filename);\n        }\n\n        self.out.push('}');\n        self.filterApplyIdx.pop();\n        break;\n\n      case _t.DOTKEY:\n        if (!prevToken || prevTokenType !== _t.VAR && prevTokenType !== _t.BRACKETCLOSE && prevTokenType !== _t.DOTKEY && prevTokenType !== _t.PARENCLOSE && prevTokenType !== _t.FUNCTIONEMPTY && prevTokenType !== _t.FILTEREMPTY && prevTokenType !== _t.CURLYCLOSE) {\n          utils.throwError('Unexpected key \"' + match + '\"', self.line, self.filename);\n        }\n\n        self.out.push('.' + match);\n        break;\n\n      case _t.OPERATOR:\n        self.out.push(' ' + match + ' ');\n        self.filterApplyIdx.pop();\n        break;\n    }\n  },\n\n  /**\n   * Parse variable token\n   * @param  {{match: string, type: number, line: number}} token      Lexer token object.\n   * @param  {string} match       Shortcut for token.match\n   * @param  {number} lastState   Lexer token type state.\n   * @return {undefined}\n   * @private\n   */\n  parseVar: function (token, match, lastState) {\n    var self = this;\n    match = match.split('.');\n\n    if (_reserved.indexOf(match[0]) !== -1) {\n      utils.throwError('Reserved keyword \"' + match[0] + '\" attempted to be used as a variable', self.line, self.filename);\n    }\n\n    self.filterApplyIdx.push(self.out.length);\n\n    if (lastState === _t.CURLYOPEN) {\n      if (match.length > 1) {\n        utils.throwError('Unexpected dot', self.line, self.filename);\n      }\n\n      self.out.push(match[0]);\n      return;\n    }\n\n    self.out.push(self.checkMatch(match));\n  },\n\n  /**\n   * Return contextual dot-check string for a match\n   * @param  {string} match       Shortcut for token.match\n   * @private\n   */\n  checkMatch: function (match) {\n    var temp = match[0],\n        result;\n\n    function checkDot(ctx) {\n      var c = ctx + temp,\n          m = match,\n          build = '';\n      build = '(typeof ' + c + ' !== \"undefined\" && ' + c + ' !== null';\n      utils.each(m, function (v, i) {\n        if (i === 0) {\n          return;\n        }\n\n        build += ' && ' + c + '.' + v + ' !== undefined && ' + c + '.' + v + ' !== null';\n        c += '.' + v;\n      });\n      build += ')';\n      return build;\n    }\n\n    function buildDot(ctx) {\n      return '(' + checkDot(ctx) + ' ? ' + ctx + match.join('.') + ' : \"\")';\n    }\n\n    result = '(' + checkDot('_ctx.') + ' ? ' + buildDot('_ctx.') + ' : ' + buildDot('') + ')';\n    return '(' + result + ' !== null ? ' + result + ' : ' + '\"\" )';\n  }\n};\n/**\n * Parse a source string into tokens that are ready for compilation.\n *\n * @example\n * exports.parse('{{ tacos }}', {}, tags, filters);\n * // => [{ compile: [Function], ... }]\n *\n * @params {object} swig    The current Swig instance\n * @param  {string} source  Swig template source.\n * @param  {object} opts    Swig options object.\n * @param  {object} tags    Keyed object of tags that can be parsed and compiled.\n * @param  {object} filters Keyed object of filters that may be applied to variables.\n * @return {array}          List of tokens ready for compilation.\n */\n\nexports.parse = function (swig, source, opts, tags, filters) {\n  source = source.replace(/\\r\\n/g, '\\n');\n  var escape = opts.autoescape,\n      tagOpen = opts.tagControls[0],\n      tagClose = opts.tagControls[1],\n      varOpen = opts.varControls[0],\n      varClose = opts.varControls[1],\n      escapedTagOpen = escapeRegExp(tagOpen),\n      escapedTagClose = escapeRegExp(tagClose),\n      escapedVarOpen = escapeRegExp(varOpen),\n      escapedVarClose = escapeRegExp(varClose),\n      tagStrip = new RegExp('^' + escapedTagOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedTagClose + '$', 'g'),\n      tagStripBefore = new RegExp('^' + escapedTagOpen + '-'),\n      tagStripAfter = new RegExp('-' + escapedTagClose + '$'),\n      varStrip = new RegExp('^' + escapedVarOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedVarClose + '$', 'g'),\n      varStripBefore = new RegExp('^' + escapedVarOpen + '-'),\n      varStripAfter = new RegExp('-' + escapedVarClose + '$'),\n      cmtOpen = opts.cmtControls[0],\n      cmtClose = opts.cmtControls[1],\n      anyChar = '[\\\\s\\\\S]*?',\n      // Split the template source based on variable, tag, and comment blocks\n  // /(\\{%[\\s\\S]*?%\\}|\\{\\{[\\s\\S]*?\\}\\}|\\{#[\\s\\S]*?#\\})/\n  splitter = new RegExp('(' + escapedTagOpen + anyChar + escapedTagClose + '|' + escapedVarOpen + anyChar + escapedVarClose + '|' + escapeRegExp(cmtOpen) + anyChar + escapeRegExp(cmtClose) + ')'),\n      line = 1,\n      stack = [],\n      parent = null,\n      tokens = [],\n      blocks = {},\n      inRaw = false,\n      stripNext;\n  /**\n   * Parse a variable.\n   * @param  {string} str  String contents of the variable, between <i>{{</i> and <i>}}</i>\n   * @param  {number} line The line number that this variable starts on.\n   * @return {VarToken}      Parsed variable token object.\n   * @private\n   */\n\n  function parseVariable(str, line) {\n    var tokens = lexer.read(utils.strip(str)),\n        parser,\n        out;\n    parser = new TokenParser(tokens, filters, escape, line, opts.filename);\n    out = parser.parse().join('');\n\n    if (parser.state.length) {\n      utils.throwError('Unable to parse \"' + str + '\"', line, opts.filename);\n    }\n    /**\n     * A parsed variable token.\n     * @typedef {object} VarToken\n     * @property {function} compile Method for compiling this token.\n     */\n\n\n    return {\n      compile: function () {\n        return '_output += ' + out + ';\\n';\n      }\n    };\n  }\n\n  exports.parseVariable = parseVariable;\n  /**\n   * Parse a tag.\n   * @param  {string} str  String contents of the tag, between <i>{%</i> and <i>%}</i>\n   * @param  {number} line The line number that this tag starts on.\n   * @return {TagToken}      Parsed token object.\n   * @private\n   */\n\n  function parseTag(str, line) {\n    var tokens, parser, chunks, tagName, tag, args, last;\n\n    if (utils.startsWith(str, 'end')) {\n      last = stack[stack.length - 1];\n\n      if (last && last.name === str.split(/\\s+/)[0].replace(/^end/, '') && last.ends) {\n        switch (last.name) {\n          case 'autoescape':\n            escape = opts.autoescape;\n            break;\n\n          case 'raw':\n            inRaw = false;\n            break;\n        }\n\n        stack.pop();\n        return;\n      }\n\n      if (!inRaw) {\n        utils.throwError('Unexpected end of tag \"' + str.replace(/^end/, '') + '\"', line, opts.filename);\n      }\n    }\n\n    if (inRaw) {\n      return;\n    }\n\n    chunks = str.split(/\\s+(.+)?/);\n    tagName = chunks.shift();\n\n    if (!tags.hasOwnProperty(tagName)) {\n      utils.throwError('Unexpected tag \"' + str + '\"', line, opts.filename);\n    }\n\n    tokens = lexer.read(utils.strip(chunks.join(' ')));\n    parser = new TokenParser(tokens, filters, false, line, opts.filename);\n    tag = tags[tagName];\n    /**\n     * Define custom parsing methods for your tag.\n     * @callback parse\n     *\n     * @example\n     * exports.parse = function (str, line, parser, types, options, swig) {\n     *   parser.on('start', function () {\n     *     // ...\n     *   });\n     *   parser.on(types.STRING, function (token) {\n     *     // ...\n     *   });\n     * };\n     *\n     * @param {string} str The full token string of the tag.\n     * @param {number} line The line number that this tag appears on.\n     * @param {TokenParser} parser A TokenParser instance.\n     * @param {TYPES} types Lexer token type enum.\n     * @param {TagToken[]} stack The current stack of open tags.\n     * @param {SwigOpts} options Swig Options Object.\n     * @param {object} swig The Swig instance (gives acces to loaders, parsers, etc)\n     */\n\n    if (!tag.parse(chunks[1], line, parser, _t, stack, opts, swig)) {\n      utils.throwError('Unexpected tag \"' + tagName + '\"', line, opts.filename);\n    }\n\n    parser.parse();\n    args = parser.out;\n\n    switch (tagName) {\n      case 'autoescape':\n        escape = args[0] !== 'false' ? args[0] : false;\n        break;\n\n      case 'raw':\n        inRaw = true;\n        break;\n    }\n    /**\n     * A parsed tag token.\n     * @typedef {Object} TagToken\n     * @property {compile} [compile] Method for compiling this token.\n     * @property {array} [args] Array of arguments for the tag.\n     * @property {Token[]} [content=[]] An array of tokens that are children of this Token.\n     * @property {boolean} [ends] Whether or not this tag requires an end tag.\n     * @property {string} name The name of this tag.\n     */\n\n\n    return {\n      block: !!tags[tagName].block,\n      compile: tag.compile,\n      args: args,\n      content: [],\n      ends: tag.ends,\n      name: tagName\n    };\n  }\n  /**\n   * Strip the whitespace from the previous token, if it is a string.\n   * @param  {object} token Parsed token.\n   * @return {object}       If the token was a string, trailing whitespace will be stripped.\n   */\n\n\n  function stripPrevToken(token) {\n    if (typeof token === 'string') {\n      token = token.replace(/\\s*$/, '');\n    }\n\n    return token;\n  }\n  /*!\n   * Loop over the source, split via the tag/var/comment regular expression splitter.\n   * Send each chunk to the appropriate parser.\n   */\n\n\n  utils.each(source.split(splitter), function (chunk) {\n    var token, lines, stripPrev, prevToken, prevChildToken;\n\n    if (!chunk) {\n      return;\n    } // Is a variable?\n\n\n    if (!inRaw && utils.startsWith(chunk, varOpen) && utils.endsWith(chunk, varClose)) {\n      stripPrev = varStripBefore.test(chunk);\n      stripNext = varStripAfter.test(chunk);\n      token = parseVariable(chunk.replace(varStrip, ''), line); // Is a tag?\n    } else if (utils.startsWith(chunk, tagOpen) && utils.endsWith(chunk, tagClose)) {\n      stripPrev = tagStripBefore.test(chunk);\n      stripNext = tagStripAfter.test(chunk);\n      token = parseTag(chunk.replace(tagStrip, ''), line);\n\n      if (token) {\n        if (token.name === 'extends') {\n          parent = token.args.join('').replace(/^\\'|\\'$/g, '').replace(/^\\\"|\\\"$/g, '');\n        } else if (token.block && !stack.length) {\n          blocks[token.args.join('')] = token;\n        }\n      }\n\n      if (inRaw && !token) {\n        token = chunk;\n      } // Is a content string?\n\n    } else if (inRaw || !utils.startsWith(chunk, cmtOpen) && !utils.endsWith(chunk, cmtClose)) {\n      token = stripNext ? chunk.replace(/^\\s*/, '') : chunk;\n      stripNext = false;\n    } else if (utils.startsWith(chunk, cmtOpen) && utils.endsWith(chunk, cmtClose)) {\n      return;\n    } // Did this tag ask to strip previous whitespace? <code>{%- ... %}</code> or <code>{{- ... }}</code>\n\n\n    if (stripPrev && tokens.length) {\n      prevToken = tokens.pop();\n\n      if (typeof prevToken === 'string') {\n        prevToken = stripPrevToken(prevToken);\n      } else if (prevToken.content && prevToken.content.length) {\n        prevChildToken = stripPrevToken(prevToken.content.pop());\n        prevToken.content.push(prevChildToken);\n      }\n\n      tokens.push(prevToken);\n    } // This was a comment, so let's just keep going.\n\n\n    if (!token) {\n      return;\n    } // If there's an open item in the stack, add this to its content.\n\n\n    if (stack.length) {\n      stack[stack.length - 1].content.push(token);\n    } else {\n      tokens.push(token);\n    } // If the token is a tag that requires an end tag, open it on the stack.\n\n\n    if (token.name && token.ends) {\n      stack.push(token);\n    }\n\n    lines = chunk.match(/\\n/g);\n    line += lines ? lines.length : 0;\n  });\n  return {\n    name: opts.filename,\n    parent: parent,\n    tokens: tokens,\n    blocks: blocks\n  };\n};\n/**\n * Compile an array of tokens.\n * @param  {Token[]} template     An array of template tokens.\n * @param  {Templates[]} parents  Array of parent templates.\n * @param  {SwigOpts} [options]   Swig options object.\n * @param  {string} [blockName]   Name of the current block context.\n * @return {string}               Partial for a compiled JavaScript method that will output a rendered template.\n */\n\n\nexports.compile = function (template, parents, options, blockName) {\n  var out = '',\n      tokens = utils.isArray(template) ? template : template.tokens;\n  utils.each(tokens, function (token) {\n    var o;\n\n    if (typeof token === 'string') {\n      out += '_output += \"' + token.replace(/\\\\/g, '\\\\\\\\').replace(/\\n|\\r/g, '\\\\n').replace(/\"/g, '\\\\\"') + '\";\\n';\n      return;\n    }\n    /**\n     * Compile callback for VarToken and TagToken objects.\n     * @callback compile\n     *\n     * @example\n     * exports.compile = function (compiler, args, content, parents, options, blockName) {\n     *   if (args[0] === 'foo') {\n     *     return compiler(content, parents, options, blockName) + '\\n';\n     *   }\n     *   return '_output += \"fallback\";\\n';\n     * };\n     *\n     * @param {parserCompiler} compiler\n     * @param {array} [args] Array of parsed arguments on the for the token.\n     * @param {array} [content] Array of content within the token.\n     * @param {array} [parents] Array of parent templates for the current template context.\n     * @param {SwigOpts} [options] Swig Options Object\n     * @param {string} [blockName] Name of the direct block parent, if any.\n     */\n\n\n    o = token.compile(exports.compile, token.args ? token.args.slice(0) : [], token.content ? token.content.slice(0) : [], parents, options, blockName);\n    out += o || '';\n  });\n  return out;\n};","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/swig/lib/parser.js"],"names":["utils","require","lexer","_t","types","_reserved","escapeRegExp","str","replace","TokenParser","tokens","filters","autoescape","line","filename","out","state","filterApplyIdx","_parsers","escape","parse","self","start","call","each","token","i","prevToken","isLast","length","type","WHITESPACE","parseToken","end","FILTER","match","COMMA","STRING","String","PARENCLOSE","FILTEREMPTY","prototype","on","fn","prevTokenType","lastState","temp","OPERATOR","push","METHODOPEN","pop","NUMBER","BOOL","hasOwnProperty","throwError","safe","splice","FUNCTION","FUNCTIONEMPTY","PARENOPEN","VAR","split","slice","checkMatch","ARRAYOPEN","CURLYOPEN","COLON","LOGIC","COMPARATOR","BRACKETOPEN","NOT","parseVar","BRACKETCLOSE","CURLYCLOSE","DOTKEY","indexOf","result","checkDot","ctx","c","m","build","v","buildDot","join","exports","swig","source","opts","tags","tagOpen","tagControls","tagClose","varOpen","varControls","varClose","escapedTagOpen","escapedTagClose","escapedVarOpen","escapedVarClose","tagStrip","RegExp","tagStripBefore","tagStripAfter","varStrip","varStripBefore","varStripAfter","cmtOpen","cmtControls","cmtClose","anyChar","splitter","stack","parent","blocks","inRaw","stripNext","parseVariable","read","strip","parser","compile","parseTag","chunks","tagName","tag","args","last","startsWith","name","ends","shift","block","content","stripPrevToken","chunk","lines","stripPrev","prevChildToken","endsWith","test","template","parents","options","blockName","isArray","o"],"mappings":"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","sourcesContent":["var utils = require('./utils'),\n  lexer = require('./lexer');\n\nvar _t = lexer.types,\n  _reserved = ['break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with'];\n\n\n/**\n * Filters are simply functions that perform transformations on their first input argument.\n * Filters are run at render time, so they may not directly modify the compiled template structure in any way.\n * All of Swig's built-in filters are written in this same way. For more examples, reference the `filters.js` file in Swig's source.\n *\n * To disable auto-escaping on a custom filter, simply add a property to the filter method `safe = true;` and the output from this will not be escaped, no matter what the global settings are for Swig.\n *\n * @typedef {function} Filter\n *\n * @example\n * // This filter will return 'bazbop' if the idx on the input is not 'foobar'\n * swig.setFilter('foobar', function (input, idx) {\n *   return input[idx] === 'foobar' ? input[idx] : 'bazbop';\n * });\n * // myvar = ['foo', 'bar', 'baz', 'bop'];\n * // => {{ myvar|foobar(3) }}\n * // Since myvar[3] !== 'foobar', we render:\n * // => bazbop\n *\n * @example\n * // This filter will disable auto-escaping on its output:\n * function bazbop (input) { return input; }\n * bazbop.safe = true;\n * swig.setFilter('bazbop', bazbop);\n * // => {{ \"<p>\"|bazbop }}\n * // => <p>\n *\n * @param {*} input Input argument, automatically sent from Swig's built-in parser.\n * @param {...*} [args] All other arguments are defined by the Filter author.\n * @return {*}\n */\n\n/*!\n * Makes a string safe for a regular expression.\n * @param  {string} str\n * @return {string}\n * @private\n */\nfunction escapeRegExp(str) {\n  return str.replace(/[\\-\\/\\\\\\^$*+?.()|\\[\\]{}]/g, '\\\\$&');\n}\n\n/**\n * Parse strings of variables and tags into tokens for future compilation.\n * @class\n * @param {array}   tokens     Pre-split tokens read by the Lexer.\n * @param {object}  filters    Keyed object of filters that may be applied to variables.\n * @param {boolean} autoescape Whether or not this should be autoescaped.\n * @param {number}  line       Beginning line number for the first token.\n * @param {string}  [filename] Name of the file being parsed.\n * @private\n */\nfunction TokenParser(tokens, filters, autoescape, line, filename) {\n  this.out = [];\n  this.state = [];\n  this.filterApplyIdx = [];\n  this._parsers = {};\n  this.line = line;\n  this.filename = filename;\n  this.filters = filters;\n  this.escape = autoescape;\n\n  this.parse = function () {\n    var self = this;\n\n    if (self._parsers.start) {\n      self._parsers.start.call(self);\n    }\n    utils.each(tokens, function (token, i) {\n      var prevToken = tokens[i - 1];\n      self.isLast = (i === tokens.length - 1);\n      if (prevToken) {\n        while (prevToken.type === _t.WHITESPACE) {\n          i -= 1;\n          prevToken = tokens[i - 1];\n        }\n      }\n      self.prevToken = prevToken;\n      self.parseToken(token);\n    });\n    if (self._parsers.end) {\n      self._parsers.end.call(self);\n    }\n\n    if (self.escape) {\n      self.filterApplyIdx = [0];\n      if (typeof self.escape === 'string') {\n        self.parseToken({ type: _t.FILTER, match: 'e' });\n        self.parseToken({ type: _t.COMMA, match: ',' });\n        self.parseToken({ type: _t.STRING, match: String(autoescape) });\n        self.parseToken({ type: _t.PARENCLOSE, match: ')'});\n      } else {\n        self.parseToken({ type: _t.FILTEREMPTY, match: 'e' });\n      }\n    }\n\n    return self.out;\n  };\n}\n\nTokenParser.prototype = {\n  /**\n   * Set a custom method to be called when a token type is found.\n   *\n   * @example\n   * parser.on(types.STRING, function (token) {\n   *   this.out.push(token.match);\n   * });\n   * @example\n   * parser.on('start', function () {\n   *   this.out.push('something at the beginning of your args')\n   * });\n   * parser.on('end', function () {\n   *   this.out.push('something at the end of your args');\n   * });\n   *\n   * @param  {number}   type Token type ID. Found in the Lexer.\n   * @param  {Function} fn   Callback function. Return true to continue executing the default parsing function.\n   * @return {undefined}\n   */\n  on: function (type, fn) {\n    this._parsers[type] = fn;\n  },\n\n  /**\n   * Parse a single token.\n   * @param  {{match: string, type: number, line: number}} token Lexer token object.\n   * @return {undefined}\n   * @private\n   */\n  parseToken: function (token) {\n    var self = this,\n      fn = self._parsers[token.type] || self._parsers['*'],\n      match = token.match,\n      prevToken = self.prevToken,\n      prevTokenType = prevToken ? prevToken.type : null,\n      lastState = (self.state.length) ? self.state[self.state.length - 1] : null,\n      temp;\n\n    if (fn && typeof fn === 'function') {\n      if (!fn.call(this, token)) {\n        return;\n      }\n    }\n\n    if (lastState && prevToken &&\n        lastState === _t.FILTER &&\n        prevTokenType === _t.FILTER &&\n        token.type !== _t.PARENCLOSE &&\n        token.type !== _t.COMMA &&\n        token.type !== _t.OPERATOR &&\n        token.type !== _t.FILTER &&\n        token.type !== _t.FILTEREMPTY) {\n      self.out.push(', ');\n    }\n\n    if (lastState && lastState === _t.METHODOPEN) {\n      self.state.pop();\n      if (token.type !== _t.PARENCLOSE) {\n        self.out.push(', ');\n      }\n    }\n\n    switch (token.type) {\n    case _t.WHITESPACE:\n      break;\n\n    case _t.STRING:\n      self.filterApplyIdx.push(self.out.length);\n      self.out.push(match.replace(/\\\\/g, '\\\\\\\\'));\n      break;\n\n    case _t.NUMBER:\n    case _t.BOOL:\n      self.filterApplyIdx.push(self.out.length);\n      self.out.push(match);\n      break;\n\n    case _t.FILTER:\n      if (!self.filters.hasOwnProperty(match) || typeof self.filters[match] !== \"function\") {\n        utils.throwError('Invalid filter \"' + match + '\"', self.line, self.filename);\n      }\n      self.escape = self.filters[match].safe ? false : self.escape;\n      self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '_filters[\"' + match + '\"](');\n      self.state.push(token.type);\n      break;\n\n    case _t.FILTEREMPTY:\n      if (!self.filters.hasOwnProperty(match) || typeof self.filters[match] !== \"function\") {\n        utils.throwError('Invalid filter \"' + match + '\"', self.line, self.filename);\n      }\n      self.escape = self.filters[match].safe ? false : self.escape;\n      self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '_filters[\"' + match + '\"](');\n      self.out.push(')');\n      break;\n\n    case _t.FUNCTION:\n    case _t.FUNCTIONEMPTY:\n      self.out.push('((typeof _ctx.' + match + ' !== \"undefined\") ? _ctx.' + match +\n        ' : ((typeof ' + match + ' !== \"undefined\") ? ' + match +\n        ' : _fn))(');\n      self.escape = false;\n      if (token.type === _t.FUNCTIONEMPTY) {\n        self.out[self.out.length - 1] = self.out[self.out.length - 1] + ')';\n      } else {\n        self.state.push(token.type);\n      }\n      self.filterApplyIdx.push(self.out.length - 1);\n      break;\n\n    case _t.PARENOPEN:\n      self.state.push(token.type);\n      if (self.filterApplyIdx.length) {\n        self.out.splice(self.filterApplyIdx[self.filterApplyIdx.length - 1], 0, '(');\n        if (prevToken && prevTokenType === _t.VAR) {\n          temp = prevToken.match.split('.').slice(0, -1);\n          self.out.push(' || _fn).call(' + self.checkMatch(temp));\n          self.state.push(_t.METHODOPEN);\n          self.escape = false;\n        } else {\n          self.out.push(' || _fn)(');\n        }\n        self.filterApplyIdx.push(self.out.length - 3);\n      } else {\n        self.out.push('(');\n        self.filterApplyIdx.push(self.out.length - 1);\n      }\n      break;\n\n    case _t.PARENCLOSE:\n      temp = self.state.pop();\n      if (temp !== _t.PARENOPEN && temp !== _t.FUNCTION && temp !== _t.FILTER) {\n        utils.throwError('Mismatched nesting state', self.line, self.filename);\n      }\n      self.out.push(')');\n      // Once off the previous entry\n      self.filterApplyIdx.pop();\n      if (temp !== _t.FILTER) {\n        // Once for the open paren\n        self.filterApplyIdx.pop();\n      }\n      break;\n\n    case _t.COMMA:\n      if (lastState !== _t.FUNCTION &&\n          lastState !== _t.FILTER &&\n          lastState !== _t.ARRAYOPEN &&\n          lastState !== _t.CURLYOPEN &&\n          lastState !== _t.PARENOPEN &&\n          lastState !== _t.COLON) {\n        utils.throwError('Unexpected comma', self.line, self.filename);\n      }\n      if (lastState === _t.COLON) {\n        self.state.pop();\n      }\n      self.out.push(', ');\n      self.filterApplyIdx.pop();\n      break;\n\n    case _t.LOGIC:\n    case _t.COMPARATOR:\n      if (!prevToken ||\n          prevTokenType === _t.COMMA ||\n          prevTokenType === token.type ||\n          prevTokenType === _t.BRACKETOPEN ||\n          prevTokenType === _t.CURLYOPEN ||\n          prevTokenType === _t.PARENOPEN ||\n          prevTokenType === _t.FUNCTION) {\n        utils.throwError('Unexpected logic', self.line, self.filename);\n      }\n      self.out.push(token.match);\n      break;\n\n    case _t.NOT:\n      self.out.push(token.match);\n      break;\n\n    case _t.VAR:\n      self.parseVar(token, match, lastState);\n      break;\n\n    case _t.BRACKETOPEN:\n      if (!prevToken ||\n          (prevTokenType !== _t.VAR &&\n            prevTokenType !== _t.BRACKETCLOSE &&\n            prevTokenType !== _t.PARENCLOSE)) {\n        self.state.push(_t.ARRAYOPEN);\n        self.filterApplyIdx.push(self.out.length);\n      } else {\n        self.state.push(token.type);\n      }\n      self.out.push('[');\n      break;\n\n    case _t.BRACKETCLOSE:\n      temp = self.state.pop();\n      if (temp !== _t.BRACKETOPEN && temp !== _t.ARRAYOPEN) {\n        utils.throwError('Unexpected closing square bracket', self.line, self.filename);\n      }\n      self.out.push(']');\n      self.filterApplyIdx.pop();\n      break;\n\n    case _t.CURLYOPEN:\n      self.state.push(token.type);\n      self.out.push('{');\n      self.filterApplyIdx.push(self.out.length - 1);\n      break;\n\n    case _t.COLON:\n      if (lastState !== _t.CURLYOPEN) {\n        utils.throwError('Unexpected colon', self.line, self.filename);\n      }\n      self.state.push(token.type);\n      self.out.push(':');\n      self.filterApplyIdx.pop();\n      break;\n\n    case _t.CURLYCLOSE:\n      if (lastState === _t.COLON) {\n        self.state.pop();\n      }\n      if (self.state.pop() !== _t.CURLYOPEN) {\n        utils.throwError('Unexpected closing curly brace', self.line, self.filename);\n      }\n      self.out.push('}');\n\n      self.filterApplyIdx.pop();\n      break;\n\n    case _t.DOTKEY:\n      if (!prevToken || (\n          prevTokenType !== _t.VAR &&\n          prevTokenType !== _t.BRACKETCLOSE &&\n          prevTokenType !== _t.DOTKEY &&\n          prevTokenType !== _t.PARENCLOSE &&\n          prevTokenType !== _t.FUNCTIONEMPTY &&\n          prevTokenType !== _t.FILTEREMPTY &&\n          prevTokenType !== _t.CURLYCLOSE\n        )) {\n        utils.throwError('Unexpected key \"' + match + '\"', self.line, self.filename);\n      }\n      self.out.push('.' + match);\n      break;\n\n    case _t.OPERATOR:\n      self.out.push(' ' + match + ' ');\n      self.filterApplyIdx.pop();\n      break;\n    }\n  },\n\n  /**\n   * Parse variable token\n   * @param  {{match: string, type: number, line: number}} token      Lexer token object.\n   * @param  {string} match       Shortcut for token.match\n   * @param  {number} lastState   Lexer token type state.\n   * @return {undefined}\n   * @private\n   */\n  parseVar: function (token, match, lastState) {\n    var self = this;\n\n    match = match.split('.');\n\n    if (_reserved.indexOf(match[0]) !== -1) {\n      utils.throwError('Reserved keyword \"' + match[0] + '\" attempted to be used as a variable', self.line, self.filename);\n    }\n\n    self.filterApplyIdx.push(self.out.length);\n    if (lastState === _t.CURLYOPEN) {\n      if (match.length > 1) {\n        utils.throwError('Unexpected dot', self.line, self.filename);\n      }\n      self.out.push(match[0]);\n      return;\n    }\n\n    self.out.push(self.checkMatch(match));\n  },\n\n  /**\n   * Return contextual dot-check string for a match\n   * @param  {string} match       Shortcut for token.match\n   * @private\n   */\n  checkMatch: function (match) {\n    var temp = match[0], result;\n\n    function checkDot(ctx) {\n      var c = ctx + temp,\n        m = match,\n        build = '';\n\n      build = '(typeof ' + c + ' !== \"undefined\" && ' + c + ' !== null';\n      utils.each(m, function (v, i) {\n        if (i === 0) {\n          return;\n        }\n        build += ' && ' + c + '.' + v + ' !== undefined && ' + c + '.' + v + ' !== null';\n        c += '.' + v;\n      });\n      build += ')';\n\n      return build;\n    }\n\n    function buildDot(ctx) {\n      return '(' + checkDot(ctx) + ' ? ' + ctx + match.join('.') + ' : \"\")';\n    }\n    result = '(' + checkDot('_ctx.') + ' ? ' + buildDot('_ctx.') + ' : ' + buildDot('') + ')';\n    return '(' + result + ' !== null ? ' + result + ' : ' + '\"\" )';\n  }\n};\n\n/**\n * Parse a source string into tokens that are ready for compilation.\n *\n * @example\n * exports.parse('{{ tacos }}', {}, tags, filters);\n * // => [{ compile: [Function], ... }]\n *\n * @params {object} swig    The current Swig instance\n * @param  {string} source  Swig template source.\n * @param  {object} opts    Swig options object.\n * @param  {object} tags    Keyed object of tags that can be parsed and compiled.\n * @param  {object} filters Keyed object of filters that may be applied to variables.\n * @return {array}          List of tokens ready for compilation.\n */\nexports.parse = function (swig, source, opts, tags, filters) {\n  source = source.replace(/\\r\\n/g, '\\n');\n  var escape = opts.autoescape,\n    tagOpen = opts.tagControls[0],\n    tagClose = opts.tagControls[1],\n    varOpen = opts.varControls[0],\n    varClose = opts.varControls[1],\n    escapedTagOpen = escapeRegExp(tagOpen),\n    escapedTagClose = escapeRegExp(tagClose),\n    escapedVarOpen = escapeRegExp(varOpen),\n    escapedVarClose = escapeRegExp(varClose),\n    tagStrip = new RegExp('^' + escapedTagOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedTagClose + '$', 'g'),\n    tagStripBefore = new RegExp('^' + escapedTagOpen + '-'),\n    tagStripAfter = new RegExp('-' + escapedTagClose + '$'),\n    varStrip = new RegExp('^' + escapedVarOpen + '-?\\\\s*-?|-?\\\\s*-?' + escapedVarClose + '$', 'g'),\n    varStripBefore = new RegExp('^' + escapedVarOpen + '-'),\n    varStripAfter = new RegExp('-' + escapedVarClose + '$'),\n    cmtOpen = opts.cmtControls[0],\n    cmtClose = opts.cmtControls[1],\n    anyChar = '[\\\\s\\\\S]*?',\n    // Split the template source based on variable, tag, and comment blocks\n    // /(\\{%[\\s\\S]*?%\\}|\\{\\{[\\s\\S]*?\\}\\}|\\{#[\\s\\S]*?#\\})/\n    splitter = new RegExp(\n      '(' +\n        escapedTagOpen + anyChar + escapedTagClose + '|' +\n        escapedVarOpen + anyChar + escapedVarClose + '|' +\n        escapeRegExp(cmtOpen) + anyChar + escapeRegExp(cmtClose) +\n        ')'\n    ),\n    line = 1,\n    stack = [],\n    parent = null,\n    tokens = [],\n    blocks = {},\n    inRaw = false,\n    stripNext;\n\n  /**\n   * Parse a variable.\n   * @param  {string} str  String contents of the variable, between <i>{{</i> and <i>}}</i>\n   * @param  {number} line The line number that this variable starts on.\n   * @return {VarToken}      Parsed variable token object.\n   * @private\n   */\n  function parseVariable(str, line) {\n    var tokens = lexer.read(utils.strip(str)),\n      parser,\n      out;\n\n    parser = new TokenParser(tokens, filters, escape, line, opts.filename);\n    out = parser.parse().join('');\n\n    if (parser.state.length) {\n      utils.throwError('Unable to parse \"' + str + '\"', line, opts.filename);\n    }\n\n    /**\n     * A parsed variable token.\n     * @typedef {object} VarToken\n     * @property {function} compile Method for compiling this token.\n     */\n    return {\n      compile: function () {\n        return '_output += ' + out + ';\\n';\n      }\n    };\n  }\n  exports.parseVariable = parseVariable;\n\n  /**\n   * Parse a tag.\n   * @param  {string} str  String contents of the tag, between <i>{%</i> and <i>%}</i>\n   * @param  {number} line The line number that this tag starts on.\n   * @return {TagToken}      Parsed token object.\n   * @private\n   */\n  function parseTag(str, line) {\n    var tokens, parser, chunks, tagName, tag, args, last;\n\n    if (utils.startsWith(str, 'end')) {\n      last = stack[stack.length - 1];\n      if (last && last.name === str.split(/\\s+/)[0].replace(/^end/, '') && last.ends) {\n        switch (last.name) {\n        case 'autoescape':\n          escape = opts.autoescape;\n          break;\n        case 'raw':\n          inRaw = false;\n          break;\n        }\n        stack.pop();\n        return;\n      }\n\n      if (!inRaw) {\n        utils.throwError('Unexpected end of tag \"' + str.replace(/^end/, '') + '\"', line, opts.filename);\n      }\n    }\n\n    if (inRaw) {\n      return;\n    }\n\n    chunks = str.split(/\\s+(.+)?/);\n    tagName = chunks.shift();\n\n    if (!tags.hasOwnProperty(tagName)) {\n      utils.throwError('Unexpected tag \"' + str + '\"', line, opts.filename);\n    }\n\n    tokens = lexer.read(utils.strip(chunks.join(' ')));\n    parser = new TokenParser(tokens, filters, false, line, opts.filename);\n    tag = tags[tagName];\n\n    /**\n     * Define custom parsing methods for your tag.\n     * @callback parse\n     *\n     * @example\n     * exports.parse = function (str, line, parser, types, options, swig) {\n     *   parser.on('start', function () {\n     *     // ...\n     *   });\n     *   parser.on(types.STRING, function (token) {\n     *     // ...\n     *   });\n     * };\n     *\n     * @param {string} str The full token string of the tag.\n     * @param {number} line The line number that this tag appears on.\n     * @param {TokenParser} parser A TokenParser instance.\n     * @param {TYPES} types Lexer token type enum.\n     * @param {TagToken[]} stack The current stack of open tags.\n     * @param {SwigOpts} options Swig Options Object.\n     * @param {object} swig The Swig instance (gives acces to loaders, parsers, etc)\n     */\n    if (!tag.parse(chunks[1], line, parser, _t, stack, opts, swig)) {\n      utils.throwError('Unexpected tag \"' + tagName + '\"', line, opts.filename);\n    }\n\n    parser.parse();\n    args = parser.out;\n\n    switch (tagName) {\n    case 'autoescape':\n      escape = (args[0] !== 'false') ? args[0] : false;\n      break;\n    case 'raw':\n      inRaw = true;\n      break;\n    }\n\n    /**\n     * A parsed tag token.\n     * @typedef {Object} TagToken\n     * @property {compile} [compile] Method for compiling this token.\n     * @property {array} [args] Array of arguments for the tag.\n     * @property {Token[]} [content=[]] An array of tokens that are children of this Token.\n     * @property {boolean} [ends] Whether or not this tag requires an end tag.\n     * @property {string} name The name of this tag.\n     */\n    return {\n      block: !!tags[tagName].block,\n      compile: tag.compile,\n      args: args,\n      content: [],\n      ends: tag.ends,\n      name: tagName\n    };\n  }\n\n  /**\n   * Strip the whitespace from the previous token, if it is a string.\n   * @param  {object} token Parsed token.\n   * @return {object}       If the token was a string, trailing whitespace will be stripped.\n   */\n  function stripPrevToken(token) {\n    if (typeof token === 'string') {\n      token = token.replace(/\\s*$/, '');\n    }\n    return token;\n  }\n\n  /*!\n   * Loop over the source, split via the tag/var/comment regular expression splitter.\n   * Send each chunk to the appropriate parser.\n   */\n  utils.each(source.split(splitter), function (chunk) {\n    var token, lines, stripPrev, prevToken, prevChildToken;\n\n    if (!chunk) {\n      return;\n    }\n\n    // Is a variable?\n    if (!inRaw && utils.startsWith(chunk, varOpen) && utils.endsWith(chunk, varClose)) {\n      stripPrev = varStripBefore.test(chunk);\n      stripNext = varStripAfter.test(chunk);\n      token = parseVariable(chunk.replace(varStrip, ''), line);\n    // Is a tag?\n    } else if (utils.startsWith(chunk, tagOpen) && utils.endsWith(chunk, tagClose)) {\n      stripPrev = tagStripBefore.test(chunk);\n      stripNext = tagStripAfter.test(chunk);\n      token = parseTag(chunk.replace(tagStrip, ''), line);\n      if (token) {\n        if (token.name === 'extends') {\n          parent = token.args.join('').replace(/^\\'|\\'$/g, '').replace(/^\\\"|\\\"$/g, '');\n        } else if (token.block && !stack.length) {\n          blocks[token.args.join('')] = token;\n        }\n      }\n      if (inRaw && !token) {\n        token = chunk;\n      }\n    // Is a content string?\n    } else if (inRaw || (!utils.startsWith(chunk, cmtOpen) && !utils.endsWith(chunk, cmtClose))) {\n      token = (stripNext) ? chunk.replace(/^\\s*/, '') : chunk;\n      stripNext = false;\n    } else if (utils.startsWith(chunk, cmtOpen) && utils.endsWith(chunk, cmtClose)) {\n      return;\n    }\n\n    // Did this tag ask to strip previous whitespace? <code>{%- ... %}</code> or <code>{{- ... }}</code>\n    if (stripPrev && tokens.length) {\n      prevToken = tokens.pop();\n      if (typeof prevToken === 'string') {\n        prevToken = stripPrevToken(prevToken);\n      } else if (prevToken.content && prevToken.content.length) {\n        prevChildToken = stripPrevToken(prevToken.content.pop());\n        prevToken.content.push(prevChildToken);\n      }\n      tokens.push(prevToken);\n    }\n\n    // This was a comment, so let's just keep going.\n    if (!token) {\n      return;\n    }\n\n    // If there's an open item in the stack, add this to its content.\n    if (stack.length) {\n      stack[stack.length - 1].content.push(token);\n    } else {\n      tokens.push(token);\n    }\n\n    // If the token is a tag that requires an end tag, open it on the stack.\n    if (token.name && token.ends) {\n      stack.push(token);\n    }\n\n    lines = chunk.match(/\\n/g);\n    line += (lines) ? lines.length : 0;\n  });\n\n  return {\n    name: opts.filename,\n    parent: parent,\n    tokens: tokens,\n    blocks: blocks\n  };\n};\n\n\n/**\n * Compile an array of tokens.\n * @param  {Token[]} template     An array of template tokens.\n * @param  {Templates[]} parents  Array of parent templates.\n * @param  {SwigOpts} [options]   Swig options object.\n * @param  {string} [blockName]   Name of the current block context.\n * @return {string}               Partial for a compiled JavaScript method that will output a rendered template.\n */\nexports.compile = function (template, parents, options, blockName) {\n  var out = '',\n    tokens = utils.isArray(template) ? template : template.tokens;\n\n  utils.each(tokens, function (token) {\n    var o;\n    if (typeof token === 'string') {\n      out += '_output += \"' + token.replace(/\\\\/g, '\\\\\\\\').replace(/\\n|\\r/g, '\\\\n').replace(/\"/g, '\\\\\"') + '\";\\n';\n      return;\n    }\n\n    /**\n     * Compile callback for VarToken and TagToken objects.\n     * @callback compile\n     *\n     * @example\n     * exports.compile = function (compiler, args, content, parents, options, blockName) {\n     *   if (args[0] === 'foo') {\n     *     return compiler(content, parents, options, blockName) + '\\n';\n     *   }\n     *   return '_output += \"fallback\";\\n';\n     * };\n     *\n     * @param {parserCompiler} compiler\n     * @param {array} [args] Array of parsed arguments on the for the token.\n     * @param {array} [content] Array of content within the token.\n     * @param {array} [parents] Array of parent templates for the current template context.\n     * @param {SwigOpts} [options] Swig Options Object\n     * @param {string} [blockName] Name of the direct block parent, if any.\n     */\n    o = token.compile(exports.compile, token.args ? token.args.slice(0) : [], token.content ? token.content.slice(0) : [], parents, options, blockName);\n    out += o || '';\n  });\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"script"}
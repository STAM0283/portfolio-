{"ast":null,"code":"var nativeHttps = require('https'),\n    nativeHttp = require('http'),\n    url = require('url'),\n    _ = require('underscore');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n}; // Only use GETs on redirects\n\nfor (var protocol in protocols) {\n  // h is either our cloned http or https object\n  var h = function () {};\n\n  h.prototype = protocols[protocol];\n  h = new h();\n  module.exports[protocol] = h;\n\n  h.request = function (h) {\n    return function (options, callback, redirectOptions) {\n      redirectOptions = redirectOptions || {};\n      var max = typeof options === 'object' && 'maxRedirects' in options ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = _.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions); //console.log(redirect.count);\n      //console.log(redirect.max);\n\n      /**\n       * Emit error if too many redirects\n       */\n\n\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n      /**\n       * Parse URL from options\n       */\n\n      var reqUrl;\n\n      if (typeof options === 'string') {\n        reqUrl = options;\n      } else {\n        reqUrl = url.format(_.extend({\n          protocol: protocol\n        }, options));\n      }\n      /*\n       * Build client request\n       */\n\n\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect)); // Save user's clientRequest so we can emit errors later\n\n\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n      /**\n       * ClientRequest callback for redirects\n       */\n\n      function redirectCallback(reqUrl, redirect) {\n        return function (res) {\n          // status must be 300-399 for redirects\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          } // no `Location:` header => nowhere to redirect\n\n\n          if (!('location' in res.headers)) {\n            //console.log('[no location header] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          } // save the original clientRequest to our redirectOptions so we can emit errors later\n          // need to use url.resolve() in case location is a relative URL\n\n\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']); // we need to call the right api (http vs https) depending on protocol\n\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1); //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);\n\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    };\n  }(h); // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n\n\n  h.get = function (h) {\n    return function (options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n}","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/mailcomposer/node_modules/follow-redirects/index.js"],"names":["nativeHttps","require","nativeHttp","url","_","maxRedirects","module","exports","protocols","https","http","protocol","h","prototype","request","options","callback","redirectOptions","max","redirect","extend","count","clientRequest","userCallback","err","Error","emit","reqUrl","format","__proto__","redirectCallback","res","statusCode","headers","redirectUrl","resolve","proto","parse","substr","length","get","cb","req","end"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,OAAO,CAAC,OAAD,CAAzB;AAAA,IACEC,UAAU,GAAGD,OAAO,CAAC,MAAD,CADtB;AAAA,IAEEE,GAAG,GAAGF,OAAO,CAAC,KAAD,CAFf;AAAA,IAGEG,CAAC,GAAGH,OAAO,CAAC,YAAD,CAHb;;AAKA,IAAII,YAAY,GAAGC,MAAM,CAACC,OAAP,CAAeF,YAAf,GAA8B,CAAjD;AAEA,IAAIG,SAAS,GAAG;AACdC,EAAAA,KAAK,EAAET,WADO;AAEdU,EAAAA,IAAI,EAAER;AAFQ,CAAhB,C,CAKA;;AACA,KAAK,IAAIS,QAAT,IAAqBH,SAArB,EAAgC;AAC9B;AACA,MAAII,CAAC,GAAI,YAAW,CAAE,CAAtB;;AACAA,EAAAA,CAAC,CAACC,SAAF,GAAcL,SAAS,CAACG,QAAD,CAAvB;AACAC,EAAAA,CAAC,GAAG,IAAIA,CAAJ,EAAJ;AAEAN,EAAAA,MAAM,CAACC,OAAP,CAAeI,QAAf,IAA2BC,CAA3B;;AAEAA,EAAAA,CAAC,CAACE,OAAF,GAAY,UAAUF,CAAV,EAAa;AACvB,WAAO,UAAUG,OAAV,EAAmBC,QAAnB,EAA6BC,eAA7B,EAA8C;AAEnDA,MAAAA,eAAe,GAAGA,eAAe,IAAI,EAArC;AAEA,UAAIC,GAAG,GAAI,OAAOH,OAAP,KAAmB,QAAnB,IAA+B,kBAAkBA,OAAlD,GAA6DA,OAAO,CAACV,YAArE,GAAoFE,OAAO,CAACF,YAAtG;;AAEA,UAAIc,QAAQ,GAAGf,CAAC,CAACgB,MAAF,CAAS;AACtBC,QAAAA,KAAK,EAAE,CADe;AAEtBH,QAAAA,GAAG,EAAEA,GAFiB;AAGtBI,QAAAA,aAAa,EAAE,IAHO;AAItBC,QAAAA,YAAY,EAAEP;AAJQ,OAAT,EAKZC,eALY,CAAf,CANmD,CAanD;AACA;;AACA;;;;;AAGA,UAAIE,QAAQ,CAACE,KAAT,GAAiBF,QAAQ,CAACD,GAA9B,EAAmC;AACjC,YAAIM,GAAG,GAAG,IAAIC,KAAJ,CAAU,sFAAV,CAAV;AACAN,QAAAA,QAAQ,CAACG,aAAT,CAAuBI,IAAvB,CAA4B,OAA5B,EAAqCF,GAArC;AACA,eAAOL,QAAQ,CAACG,aAAhB;AACD;;AAEDH,MAAAA,QAAQ,CAACE,KAAT;AAEA;;;;AAGA,UAAIM,MAAJ;;AACA,UAAI,OAAOZ,OAAP,KAAmB,QAAvB,EAAiC;AAC/BY,QAAAA,MAAM,GAAGZ,OAAT;AACD,OAFD,MAGK;AACHY,QAAAA,MAAM,GAAGxB,GAAG,CAACyB,MAAJ,CAAWxB,CAAC,CAACgB,MAAF,CAAS;AAAET,UAAAA,QAAQ,EAAEA;AAAZ,SAAT,EAAiCI,OAAjC,CAAX,CAAT;AACD;AAED;;;;;AAGA,UAAIO,aAAa,GAAGV,CAAC,CAACiB,SAAF,CAAYf,OAAZ,CAAoBC,OAApB,EAA6Be,gBAAgB,CAACH,MAAD,EAASR,QAAT,CAA7C,CAApB,CAxCmD,CA0CnD;;;AACA,UAAI,CAACA,QAAQ,CAACG,aAAd,EAA6BH,QAAQ,CAACG,aAAT,GAAyBA,aAAzB;AAE7B;;;;AAGA,eAASQ,gBAAT,CAA2BH,MAA3B,EAAmCR,QAAnC,EAA6C;AAC3C,eAAO,UAAUY,GAAV,EAAe;AACpB;AACA,cAAIA,GAAG,CAACC,UAAJ,GAAiB,GAAjB,IAAwBD,GAAG,CAACC,UAAJ,GAAiB,GAA7C,EAAkD;AAChD;AACA,mBAAOb,QAAQ,CAACI,YAAT,CAAsBQ,GAAtB,CAAP;AACD,WALmB,CAOpB;;;AACA,cAAI,EAAE,cAAcA,GAAG,CAACE,OAApB,CAAJ,EAAkC;AAChC;AACA,mBAAOd,QAAQ,CAACI,YAAT,CAAsBQ,GAAtB,CAAP;AACD,WAXmB,CAapB;AAEA;;;AACA,cAAIG,WAAW,GAAG/B,GAAG,CAACgC,OAAJ,CAAYR,MAAZ,EAAoBI,GAAG,CAACE,OAAJ,CAAY,UAAZ,CAApB,CAAlB,CAhBoB,CAiBpB;;AACA,cAAIG,KAAK,GAAGjC,GAAG,CAACkC,KAAJ,CAAUH,WAAV,EAAuBvB,QAAnC;AACAyB,UAAAA,KAAK,GAAGA,KAAK,CAACE,MAAN,CAAa,CAAb,EAAgBF,KAAK,CAACG,MAAN,GAAe,CAA/B,CAAR,CAnBoB,CAoBpB;;AACA,iBAAOjC,MAAM,CAACC,OAAP,CAAe6B,KAAf,EAAsBI,GAAtB,CAA0BN,WAA1B,EAAuCJ,gBAAgB,CAACH,MAAD,EAASR,QAAT,CAAvD,EAA2EA,QAA3E,CAAP;AACD,SAtBD;AAuBD;;AAED,aAAOG,aAAP;AACD,KA3ED;AA4ED,GA7EW,CA6EVV,CA7EU,CAAZ,CAR8B,CAuF9B;;;AACAA,EAAAA,CAAC,CAAC4B,GAAF,GAAQ,UAAU5B,CAAV,EAAa;AACnB,WAAO,UAAUG,OAAV,EAAmB0B,EAAnB,EAAuBxB,eAAvB,EAAwC;AAC7C,UAAIyB,GAAG,GAAG9B,CAAC,CAACE,OAAF,CAAUC,OAAV,EAAmB0B,EAAnB,EAAuBxB,eAAvB,CAAV;AACAyB,MAAAA,GAAG,CAACC,GAAJ;AACA,aAAOD,GAAP;AACD,KAJD;AAKD,GANO,CAMN9B,CANM,CAAR;AAOD","sourcesContent":["var nativeHttps = require('https'),\n  nativeHttp = require('http'),\n  url = require('url'),\n  _ = require('underscore');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\n\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n};\n\n// Only use GETs on redirects\nfor (var protocol in protocols) {\n  // h is either our cloned http or https object\n  var h =  function() {};\n  h.prototype = protocols[protocol];\n  h = new h();\n\n  module.exports[protocol] = h;\n\n  h.request = function (h) {\n    return function (options, callback, redirectOptions) {\n\n      redirectOptions = redirectOptions || {};\n\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = _.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions);\n\n      //console.log(redirect.count);\n      //console.log(redirect.max);\n      /**\n       * Emit error if too many redirects\n       */\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n\n      /**\n       * Parse URL from options\n       */\n      var reqUrl;\n      if (typeof options === 'string') {\n        reqUrl = options;\n      }\n      else {\n        reqUrl = url.format(_.extend({ protocol: protocol }, options));\n      }\n\n      /*\n       * Build client request\n       */\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect));\n\n      // Save user's clientRequest so we can emit errors later\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n\n      /**\n       * ClientRequest callback for redirects\n       */\n      function redirectCallback (reqUrl, redirect) {\n        return function (res) {\n          // status must be 300-399 for redirects\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // no `Location:` header => nowhere to redirect\n          if (!('location' in res.headers)) {\n            //console.log('[no location header] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // save the original clientRequest to our redirectOptions so we can emit errors later\n\n          // need to use url.resolve() in case location is a relative URL\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']);\n          // we need to call the right api (http vs https) depending on protocol\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1);\n          //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    }\n  }(h);\n\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n  h.get = function (h) {\n    return function (options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var util = require('../util');\n\nvar Shape = require('../model/shape');\n\nvar xml2js = require('xml2js');\n\nvar options = {\n  // options passed to xml2js parser\n  explicitCharkey: false,\n  // undocumented\n  trim: false,\n  // trim the leading/trailing whitespace from text nodes\n  normalize: false,\n  // trim interior whitespace inside text nodes\n  explicitRoot: false,\n  // return the root node in the resulting object?\n  emptyTag: null,\n  // the default value for empty nodes\n  explicitArray: true,\n  // always put child nodes in an array\n  ignoreAttrs: false,\n  // ignore attributes, only create text nodes\n  mergeAttrs: false,\n  // merge attributes and child elements\n  validator: null // a callable validator\n\n};\n\nfunction NodeXmlParser() {}\n\nNodeXmlParser.prototype.parse = function (xml, shape) {\n  shape = shape || {};\n  var result = null;\n  var error = null;\n  var parser = new xml2js.Parser(options);\n  parser.parseString(xml, function (e, r) {\n    error = e;\n    result = r;\n  });\n\n  if (result) {\n    var data = parseXml(result, shape);\n\n    if (result.ResponseMetadata) {\n      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});\n    }\n\n    return data;\n  } else if (error) {\n    throw util.error(error, {\n      code: 'XMLParserError'\n    });\n  } else {\n    // empty xml document\n    return parseXml({}, shape);\n  }\n};\n\nfunction parseXml(xml, shape) {\n  switch (shape.type) {\n    case 'structure':\n      return parseStructure(xml, shape);\n\n    case 'map':\n      return parseMap(xml, shape);\n\n    case 'list':\n      return parseList(xml, shape);\n\n    case undefined:\n    case null:\n      return parseUnknown(xml);\n\n    default:\n      return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  util.each(shape.members, function (memberName, memberShape) {\n    var xmlName = memberShape.name;\n\n    if (xml.hasOwnProperty(xmlName) && Array.isArray(xml[xmlName])) {\n      var xmlChild = xml[xmlName];\n      if (!memberShape.flattened) xmlChild = xmlChild[0];\n      data[memberName] = parseXml(xmlChild, memberShape);\n    } else if (memberShape.isXmlAttribute && xml.$ && xml.$.hasOwnProperty(xmlName)) {\n      data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n    } else if (memberShape.type === 'list') {\n      data[memberName] = memberShape.defaultValue;\n    }\n  });\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var iterable = shape.flattened ? xml : xml.entry;\n\n  if (Array.isArray(iterable)) {\n    util.arrayEach(iterable, function (child) {\n      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n    });\n  }\n\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var name = shape.member.name || 'member';\n\n  if (shape.flattened) {\n    util.arrayEach(xml, function (xmlChild) {\n      data.push(parseXml(xmlChild, shape.member));\n    });\n  } else if (xml && Array.isArray(xml[name])) {\n    util.arrayEach(xml[name], function (child) {\n      data.push(parseXml(child, shape.member));\n    });\n  }\n\n  return data;\n}\n\nfunction parseScalar(text, shape) {\n  if (text && text.$ && text.$.encoding === 'base64') {\n    shape = new Shape.create({\n      type: text.$.encoding\n    });\n  }\n\n  if (text && text._) text = text._;\n\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n  if (typeof xml === 'string') return xml; // parse a list\n\n  if (Array.isArray(xml)) {\n    var arr = [];\n\n    for (i = 0; i < xml.length; i++) {\n      arr.push(parseXml(xml[i], {}));\n    }\n\n    return arr;\n  } // empty object\n\n\n  var keys = Object.keys(xml),\n      i;\n\n  if (keys.length === 0 || keys === ['$']) {\n    return {};\n  } // object, parse as structure\n\n\n  var data = {};\n\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i],\n        value = xml[key];\n    if (key === '$') continue;\n\n    if (value.length > 1) {\n      // this member is a list\n      data[key] = parseList(value, {\n        member: {}\n      });\n    } else {\n      // this member is a single item\n      data[key] = parseXml(value[0], {});\n    }\n  }\n\n  return data;\n}\n\nmodule.exports = NodeXmlParser;","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/aws-sdk/lib/xml/node_parser.js"],"names":["util","require","Shape","xml2js","options","explicitCharkey","trim","normalize","explicitRoot","emptyTag","explicitArray","ignoreAttrs","mergeAttrs","validator","NodeXmlParser","prototype","parse","xml","shape","result","error","parser","Parser","parseString","e","r","data","parseXml","ResponseMetadata","code","type","parseStructure","parseMap","parseList","undefined","parseUnknown","parseScalar","each","members","memberName","memberShape","xmlName","name","hasOwnProperty","Array","isArray","xmlChild","flattened","isXmlAttribute","$","defaultValue","xmlKey","key","xmlValue","value","iterable","entry","arrayEach","child","member","push","text","encoding","create","_","toType","arr","i","length","keys","Object","module","exports"],"mappings":"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","sourcesContent":["var util = require('../util');\nvar Shape = require('../model/shape');\n\nvar xml2js = require('xml2js');\n\nvar options = {  // options passed to xml2js parser\n  explicitCharkey: false, // undocumented\n  trim: false,            // trim the leading/trailing whitespace from text nodes\n  normalize: false,       // trim interior whitespace inside text nodes\n  explicitRoot: false,    // return the root node in the resulting object?\n  emptyTag: null,         // the default value for empty nodes\n  explicitArray: true,    // always put child nodes in an array\n  ignoreAttrs: false,     // ignore attributes, only create text nodes\n  mergeAttrs: false,      // merge attributes and child elements\n  validator: null         // a callable validator\n};\n\nfunction NodeXmlParser() { }\n\nNodeXmlParser.prototype.parse = function(xml, shape) {\n  shape = shape || {};\n\n  var result = null;\n  var error = null;\n\n  var parser = new xml2js.Parser(options);\n  parser.parseString(xml, function (e, r) {\n    error = e;\n    result = r;\n  });\n\n  if (result) {\n    var data = parseXml(result, shape);\n    if (result.ResponseMetadata) {\n      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error, {code: 'XMLParserError'});\n  } else { // empty xml document\n    return parseXml({}, shape);\n  }\n};\n\nfunction parseXml(xml, shape) {\n  switch(shape.type) {\n    case 'structure': return parseStructure(xml, shape);\n    case 'map': return parseMap(xml, shape);\n    case 'list': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    var xmlName = memberShape.name;\n    if (xml.hasOwnProperty(xmlName) && Array.isArray(xml[xmlName])) {\n      var xmlChild = xml[xmlName];\n      if (!memberShape.flattened) xmlChild = xmlChild[0];\n\n      data[memberName] = parseXml(xmlChild, memberShape);\n    } else if (memberShape.isXmlAttribute &&\n               xml.$ && xml.$.hasOwnProperty(xmlName)) {\n      data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n    } else if (memberShape.type === 'list') {\n      data[memberName] = memberShape.defaultValue;\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var iterable = shape.flattened ? xml : xml.entry;\n\n  if (Array.isArray(iterable)) {\n    util.arrayEach(iterable, function(child) {\n      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n    });\n  }\n\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var name = shape.member.name || 'member';\n  if (shape.flattened) {\n    util.arrayEach(xml, function(xmlChild) {\n      data.push(parseXml(xmlChild, shape.member));\n    });\n  } else if (xml && Array.isArray(xml[name])) {\n    util.arrayEach(xml[name], function(child) {\n      data.push(parseXml(child, shape.member));\n    });\n  }\n\n  return data;\n}\n\nfunction parseScalar(text, shape) {\n  if (text && text.$ && text.$.encoding === 'base64') {\n    shape = new Shape.create({type: text.$.encoding});\n  }\n  if (text && text._) text = text._;\n\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n  if (typeof xml === 'string') return xml;\n\n  // parse a list\n  if (Array.isArray(xml)) {\n    var arr = [];\n    for (i = 0; i < xml.length; i++) {\n      arr.push(parseXml(xml[i], {}));\n    }\n    return arr;\n  }\n\n  // empty object\n  var keys = Object.keys(xml), i;\n  if (keys.length === 0 || keys === ['$']) {\n    return {};\n  }\n\n  // object, parse as structure\n  var data = {};\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i], value = xml[key];\n    if (key === '$') continue;\n    if (value.length > 1) { // this member is a list\n      data[key] = parseList(value, {member: {}});\n    } else { // this member is a single item\n      data[key] = parseXml(value[0], {});\n    }\n  }\n  return data;\n}\n\nmodule.exports = NodeXmlParser;\n"]},"metadata":{},"sourceType":"script"}
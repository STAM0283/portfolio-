{"ast":null,"code":"\"use strict\";\n\nvar convert = require(\"encoding\").convert,\n    addressparser = require(\"addressparser\");\n/**\n * Folds a long line according to the RFC 5322 http://tools.ietf.org/html/rfc5322#section-2.1.1\n *\n * @param {String} str Mime string that might need folding\n * @param {Number} [maxLength=76] max length for a line\n * @param {Boolean} [foldAnywhere] If true, can fold at any location (ie. in base64)\n * @param {Boolean} [afterSpace] If true fold after the space (default is before)\n * @return {String} Folded string\n */\n\n\nmodule.exports.foldLine = function (str, maxLength, foldAnywhere, afterSpace, lineMargin) {\n  if (foldAnywhere) {\n    return addBase64SoftLinebreaks(str, maxLength || 76);\n  }\n\n  return module.exports.mimeFunctions.foldLine(str, maxLength, !!afterSpace, lineMargin);\n};\n/**\n * Encodes a string into mime encoded word format http://en.wikipedia.org/wiki/MIME#Encoded-Word\n *\n * @param {String} str String to be encoded\n * @param {String} encoding Encoding Q for quoted printable or B for base64\n * @param {String} [charset=\"UTF-8\"] Charset to be used\n * @param {Number} [maxLength] If set, split on maxLength\n * @return {String} Mime word encoded string\n */\n\n\nmodule.exports.encodeMimeWord = function (str, encoding, charset, maxLength) {\n  return module.exports.mimeFunctions.encodeMimeWord(str, encoding, maxLength || 0, charset);\n};\n/**\n * Encodes need parts of a string to mime word format\n *\n * @param {String} str String to be encoded\n * @param {String} encoding Encoding Q for quoted printable or B for base64\n * @param {Number} [maxLength] If set, split on maxLength\n * @param {String} [charset=\"UTF-8\"] Charset to be used\n * @return {String} String with possible mime word encoded parts\n */\n\n\nmodule.exports.encodeMimeWords = function (str, encoding, maxLength, charset) {\n  return module.exports.mimeFunctions.encodeMimeWords(str, encoding, maxLength || 0, charset);\n};\n/**\n * Decodes a string from mime encoded word\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded string\n */\n\n\nmodule.exports.decodeMimeWord = function (str) {\n  return module.exports.mimeFunctions.decodeMimeWord(str).toString(\"utf-8\");\n};\n/**\n * Decodes all mime words from a string to an unencoded string\n *\n * @param {String} str String that may include mime words\n * @return {String} Unencoded string\n */\n\n\nmodule.exports.parseMimeWords = function (str) {\n  return module.exports.mimeFunctions.decodeMimeWords(str).toString(\"utf-8\");\n};\n/**\n * Encodes a string into Quoted-printable format. Maximum line length for the\n * encoded string is always 76+2 bytes\n *\n * @param {String} str String to be encoded into Quoted-printable\n * @param {Boolean} [mimeWord] legacy parameter, not used\n * @param {String} [charset=\"UTF-8\"] Destination charset\n * @return {String} Quoted printable encoded string\n */\n\n\nmodule.exports.encodeQuotedPrintable = function (str, mimeWord, charset) {\n  if (typeof mimeWord == \"string\" && !charset) {\n    charset = mimeWord;\n    mimeWord = undefined;\n  }\n\n  return module.exports.mimeFunctions.encodeQuotedPrintable(str, charset);\n};\n/**\n * Decodes a string from Quoted-printable format\n *\n * @param {String} str String to be decoded from Quoted-printable\n * @param {Boolean} [mimeWord] legacy parameter, not used\n * @param {String} [charset=\"UTF-8\"] Source charset\n * @return {String} Decoded string\n */\n\n\nmodule.exports.decodeQuotedPrintable = function (str, mimeWord, charset) {\n  if (typeof mimeWord == \"string\" && !charset) {\n    charset = mimeWord;\n    mimeWord = undefined;\n  }\n\n  charset = (charset || \"\").toString().toUpperCase().trim();\n  var decodedString = module.exports.mimeFunctions.decodeQuotedPrintable(str, \"utf-8\", charset);\n  return charset == \"BINARY\" ? decodedString : decodedString.toString(\"utf-8\");\n};\n/**\n * Encodes a string into Base64 format. Base64 is mime-word safe\n *\n * @param {String} str String to be encoded into Base64\n * @param {String} [charset=\"UTF-8\"] Destination charset\n * @return {String} Base64 encoded string\n */\n\n\nmodule.exports.encodeBase64 = function (str, charset) {\n  return module.exports.mimeFunctions.encodeBase64(str, charset);\n};\n/**\n * Decodes a string from Base64 format\n *\n * @param {String} str String to be decoded from Base64\n * @param {String} [charset=\"UTF-8\"] Source charset\n * @return {String} Decoded string\n */\n\n\nmodule.exports.decodeBase64 = function (str, charset) {\n  return module.exports.mimeFunctions.decodeBase64(str, \"utf-8\", charset).toString(\"utf-8\");\n};\n/**\n * Parses names and addresses from a from, to, cc or bcc line\n * For example: 'Andris Reinman <andris@tr.ee>, someone@else.com'\n * will be parsed into: [{name:\"Andris Reinman\", address:\"andris@tr.ee\"}, {address: \"someone@else.com\"}]\n *\n * @param {String|Array} addresses Address line string or an array of strings\n * @return {Array} An array of parsed e-mails addresses in the form of [{name, address}]\n */\n\n\nmodule.exports.parseAddresses = function (addresses) {\n  return [].concat.apply([], [].concat(addresses).map(addressparser)).map(function (address) {\n    address.name = module.exports.parseMimeWords(address.name);\n\n    if (address.group) {\n      address.group.forEach(function (groupAddress) {\n        groupAddress.name = module.exports.parseMimeWords(groupAddress.name);\n      });\n    }\n\n    return address;\n  });\n};\n/**\n * Parses header lines into an array of objects. Output: {'x-header': ['value']}\n *\n * @param {String} headers Full header part to be parsed\n * @return {Object} Parsed headers\n */\n\n\nmodule.exports.parseHeaders = function (headers) {\n  return module.exports.mimeFunctions.parseHeaderLines(headers);\n};\n/**\n * Parses a header line to search for additional parameters. For example\n *     parseHeaderLine('text/plain; charset=utf-8')\n * will be parsed into\n *     {defaultValue: 'text/plain', charset: 'utf-8'}\n *\n * @param {String} line Single header value without key part to be parsed\n * @return {Object} Parsed value\n */\n\n\nmodule.exports.parseHeaderLine = function (line) {\n  if (!line) {\n    return {};\n  }\n\n  var result = {},\n      parts = line.split(\";\"),\n      pos;\n\n  for (var i = 0, len = parts.length; i < len; i++) {\n    pos = parts[i].indexOf(\"=\");\n\n    if (pos < 0) {\n      result[!i ? \"defaultValue\" : \"i-\" + i] = parts[i].trim();\n    } else {\n      result[parts[i].substr(0, pos).trim().toLowerCase()] = parts[i].substr(pos + 1).trim();\n    }\n  }\n\n  return result;\n};\n\nmodule.exports.mimeFunctions = {\n  mimeEncode: function (str, toCharset, fromCharset) {\n    toCharset = toCharset || \"UTF-8\";\n    fromCharset = fromCharset || \"UTF-8\";\n    var buffer = convert(str || \"\", toCharset, fromCharset),\n        ranges = [[0x09], [0x0A], [0x0D], [0x20], [0x21], [0x23, 0x3C], [0x3E], [0x40, 0x5E], [0x60, 0x7E]],\n        result = \"\";\n\n    for (var i = 0, len = buffer.length; i < len; i++) {\n      if (checkRanges(buffer[i], ranges)) {\n        result += String.fromCharCode(buffer[i]);\n        continue;\n      }\n\n      result += \"=\" + (buffer[i] < 0x10 ? \"0\" : \"\") + buffer[i].toString(16).toUpperCase();\n    }\n\n    return result;\n  },\n  mimeDecode: function (str, toCharset, fromCharset) {\n    str = (str || \"\").toString();\n    toCharset = toCharset || \"UTF-8\";\n    fromCharset = fromCharset || \"UTF-8\";\n    var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n        bufferLength = str.length - encodedBytesCount * 2,\n        chr,\n        hex,\n        buffer = new Buffer(bufferLength),\n        bufferPos = 0;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n      chr = str.charAt(i);\n\n      if (chr == \"=\" && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n        buffer[bufferPos++] = parseInt(hex, 16);\n        i += 2;\n        continue;\n      }\n\n      buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n\n    if (fromCharset.toUpperCase().trim() == \"BINARY\") {\n      return buffer;\n    }\n\n    return convert(buffer, toCharset, fromCharset);\n  },\n  encodeBase64: function (str, toCharset, fromCharset) {\n    var buffer = convert(str || \"\", toCharset, fromCharset);\n    return addSoftLinebreaks(buffer.toString(\"base64\"), \"base64\");\n  },\n  decodeBase64: function (str, toCharset, fromCharset) {\n    var buffer = new Buffer((str || \"\").toString(), \"base64\");\n    return convert(buffer, toCharset, fromCharset);\n  },\n  decodeQuotedPrintable: function (str, toCharset, fromCharset) {\n    str = (str || \"\").toString();\n    str = str.replace(/\\=(?:\\r?\\n|$)/g, \"\");\n    return this.mimeDecode(str, toCharset, fromCharset);\n  },\n  encodeQuotedPrintable: function (str, toCharset, fromCharset) {\n    var mimeEncodedStr = this.mimeEncode(str, toCharset, fromCharset); // fix line breaks\n\n    mimeEncodedStr = mimeEncodedStr.replace(/\\r?\\n|\\r/g, function () {\n      return \"\\r\\n\";\n    }).replace(/[\\t ]+$/gm, function (spaces) {\n      return spaces.replace(/ /g, \"=20\").replace(/\\t/g, \"=09\");\n    });\n    return addSoftLinebreaks(mimeEncodedStr, \"qp\");\n  },\n  encodeMimeWord: function (str, encoding, maxLength, toCharset, fromCharset) {\n    toCharset = (toCharset || \"utf-8\").toString().toUpperCase().trim();\n    encoding = (encoding || \"Q\").toString().toUpperCase().trim().charAt(0);\n    var encodedStr;\n\n    if (maxLength && maxLength > 7 + toCharset.length) {\n      maxLength -= 7 + toCharset.length;\n    }\n\n    if (encoding == \"Q\") {\n      encodedStr = this.mimeEncode(str, toCharset, fromCharset);\n      encodedStr = encodedStr.replace(/[\\r\\n\\t_]/g, function (chr) {\n        var code = chr.charCodeAt(0);\n        return \"=\" + (code < 0x10 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n      }).replace(/\\s/g, \"_\");\n    } else if (encoding == \"B\") {\n      encodedStr = convert(str || \"\", toCharset, fromCharset).toString(\"base64\").trim();\n    }\n\n    if (maxLength && encodedStr.length > maxLength) {\n      if (encoding == \"Q\") {\n        encodedStr = this.splitEncodedString(encodedStr, maxLength).join(\"?= =?\" + toCharset + \"?\" + encoding + \"?\");\n      } else {\n        encodedStr = encodedStr.replace(new RegExp(\".{\" + maxLength + \"}\", \"g\"), \"$&?= =?\" + toCharset + \"?\" + encoding + \"?\");\n\n        if (encodedStr.substr(-(\" =?\" + toCharset + \"?\" + encoding + \"?=\").length) == \" =?\" + toCharset + \"?\" + encoding + \"?=\") {\n          encodedStr = encodedStr.substr(0, encodedStr.length - (\" =?\" + toCharset + \"?\" + encoding + \"?=\").length);\n        }\n\n        if (encodedStr.substr(-(\" =?\" + toCharset + \"?\" + encoding + \"?\").length) == \" =?\" + toCharset + \"?\" + encoding + \"?\") {\n          encodedStr = encodedStr.substr(0, encodedStr.length - (\" =?\" + toCharset + \"?\" + encoding + \"?\").length);\n        }\n      }\n    }\n\n    return \"=?\" + toCharset + \"?\" + encoding + \"?\" + encodedStr + (encodedStr.substr(-2) == \"?=\" ? \"\" : \"?=\");\n  },\n  decodeMimeWord: function (str, toCharset) {\n    str = (str || \"\").toString().trim();\n    var fromCharset, encoding, match;\n    match = str.match(/^\\=\\?([\\w_\\-]+)\\?([QqBb])\\?([^\\?]*)\\?\\=$/i);\n\n    if (!match) {\n      return convert(str, toCharset);\n    }\n\n    fromCharset = match[1];\n    encoding = (match[2] || \"Q\").toString().toUpperCase();\n    str = (match[3] || \"\").replace(/_/g, \" \");\n\n    if (encoding == \"B\") {\n      return this.decodeBase64(str, toCharset, fromCharset);\n    } else if (encoding == \"Q\") {\n      return this.mimeDecode(str, toCharset, fromCharset);\n    } else {\n      return str;\n    }\n  },\n  decodeMimeWords: function (str, toCharset) {\n    var curCharset;\n    str = (str || \"\").toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, \"$1\").replace(/\\=\\?([\\w_\\-]+)\\?([QqBb])\\?[^\\?]*\\?\\=/g, function (mimeWord, charset, encoding) {\n      curCharset = charset + encoding;\n      return this.decodeMimeWord(mimeWord);\n    }.bind(this));\n    return convert(str, toCharset);\n  },\n  foldLine: function (str, lineLengthMax, afterSpace, lineMargin) {\n    lineLengthMax = lineLengthMax || 76;\n    lineMargin = lineMargin || Math.floor(lineLengthMax / 5);\n    str = (str || \"\").toString().trim();\n    var pos = 0,\n        len = str.length,\n        result = \"\",\n        line,\n        match;\n\n    while (pos < len) {\n      line = str.substr(pos, lineLengthMax);\n\n      if (line.length < lineLengthMax) {\n        result += line;\n        break;\n      }\n\n      if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n        line = match[0];\n        result += line;\n        pos += line.length;\n        continue;\n      } else if (match = line.substr(-lineMargin).match(/(\\s+)[^\\s]*$/)) {\n        line = line.substr(0, line.length - (match[0].length - (!!afterSpace ? (match[1] || \"\").length : 0)));\n      } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n        line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || \"\").length : 0));\n      }\n\n      result += line;\n      pos += line.length;\n\n      if (pos < len) {\n        result += \"\\r\\n\";\n      }\n    }\n\n    return result;\n  },\n  encodeMimeWords: function (value, encoding, maxLength, toCharset, fromCharset) {\n    var decodedValue = convert(value || \"\", \"utf-8\", fromCharset).toString(\"utf-8\"),\n        encodedValue;\n    encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, function (str) {\n      return str.length ? this.encodeMimeWord(str, encoding || \"Q\", maxLength, toCharset) : \"\";\n    }.bind(this));\n    return encodedValue;\n  },\n  encodeHeaderLine: function (key, value, toCharset, fromCharset) {\n    var encodedValue = this.encodeMimeWords(value, 52, toCharset, fromCharset);\n    return this.foldLine(key + \": \" + encodedValue, 76);\n  },\n  parseHeaderLines: function (headers, toCharset) {\n    var lines = headers.split(/\\r?\\n|\\r/),\n        headersObj = {},\n        key,\n        value,\n        header,\n        i,\n        len;\n\n    for (i = lines.length - 1; i >= 0; i--) {\n      if (i && lines[i].match(/^\\s/)) {\n        lines[i - 1] += \"\\r\\n\" + lines[i];\n        lines.splice(i, 1);\n      }\n    }\n\n    for (i = 0, len = lines.length; i < len; i++) {\n      header = this.decodeHeaderLine(lines[i]);\n      key = (header[0] || \"\").toString().toLowerCase().trim();\n      value = header[1] || \"\";\n\n      if (!toCharset || (toCharset || \"\").toString().trim().match(/^utf[\\-_]?8$/i)) {\n        value = value.toString(\"utf-8\");\n      }\n\n      if (!headersObj[key]) {\n        headersObj[key] = [value];\n      } else {\n        headersObj[key].push(value);\n      }\n    }\n\n    return headersObj;\n  },\n  decodeHeaderLine: function (header, toCharset) {\n    var line = (header || \"\").toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, \" \").trim(),\n        match = line.match(/^\\s*([^:]+):(.*)$/),\n        key = (match && match[1] || \"\").trim(),\n        value = (match && match[2] || \"\").trim();\n    value = this.decodeMimeWords(value, toCharset);\n    return [key, value];\n  },\n  splitEncodedString: function (str, maxlen) {\n    var curLine,\n        match,\n        chr,\n        done,\n        lines = [];\n\n    while (str.length) {\n      curLine = str.substr(0, maxlen); // move incomplete escaped char back to main\n\n      if (match = curLine.match(/\\=[0-9A-F]?$/i)) {\n        curLine = curLine.substr(0, match.index);\n      }\n\n      done = false;\n\n      while (!done) {\n        done = true; // check if not middle of a unicode char sequence\n\n        if (match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i)) {\n          chr = parseInt(match[1], 16); // invalid sequence, move one char back anc recheck\n\n          if (chr < 0xC2 && chr > 0x7F) {\n            curLine = curLine.substr(0, curLine.length - 3);\n            done = false;\n          }\n        }\n      }\n\n      if (curLine.length) {\n        lines.push(curLine);\n      }\n\n      str = str.substr(curLine.length);\n    }\n\n    return lines;\n  },\n  parseAddresses: addressparser\n}; // Lines can't be longer that 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\n\nfunction addSoftLinebreaks(str, encoding) {\n  var lineLengthMax = 76;\n  encoding = (encoding || \"base64\").toString().toLowerCase().trim();\n\n  if (encoding == \"qp\") {\n    return addQPSoftLinebreaks(str, lineLengthMax);\n  } else {\n    return addBase64SoftLinebreaks(str, lineLengthMax);\n  }\n}\n\nfunction addBase64SoftLinebreaks(base64EncodedStr, lineLengthMax) {\n  base64EncodedStr = (base64EncodedStr || \"\").toString().trim();\n  return base64EncodedStr.replace(new RegExp(\".{\" + lineLengthMax + \"}\", \"g\"), \"$&\\r\\n\").trim();\n}\n\nfunction addQPSoftLinebreaks(mimeEncodedStr, lineLengthMax) {\n  var pos = 0,\n      len = mimeEncodedStr.length,\n      match,\n      code,\n      line,\n      lineMargin = Math.floor(lineLengthMax / 3),\n      result = \"\"; // insert soft linebreaks where needed\n\n  while (pos < len) {\n    line = mimeEncodedStr.substr(pos, lineLengthMax);\n\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n\n    if (line.substr(-1) == \"\\n\") {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > lineLengthMax - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.substr(-1) == \"\\r\") {\n      line = line.substr(0, line.length - 1);\n    } else {\n      if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/\\=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        } // ensure that utf-8 sequences are not split\n\n\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n          code = parseInt(match[0].substr(1, 2), 16);\n\n          if (code < 128) {\n            break;\n          }\n\n          line = line.substr(0, line.length - 3);\n\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) != \"\\n\") {\n      if (line.length == 76 && line.match(/\\=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length == 76) {\n        line = line.substr(0, line.length - 1);\n      }\n\n      pos += line.length;\n      line += \"=\\r\\n\";\n    } else {\n      pos += line.length;\n    }\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction checkRanges(nr, ranges) {\n  for (var i = ranges.length - 1; i >= 0; i--) {\n    if (!ranges[i].length) {\n      continue;\n    }\n\n    if (ranges[i].length == 1 && nr == ranges[i][0]) {\n      return true;\n    }\n\n    if (ranges[i].length == 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/mimelib/lib/mimelib.js"],"names":["convert","require","addressparser","module","exports","foldLine","str","maxLength","foldAnywhere","afterSpace","lineMargin","addBase64SoftLinebreaks","mimeFunctions","encodeMimeWord","encoding","charset","encodeMimeWords","decodeMimeWord","toString","parseMimeWords","decodeMimeWords","encodeQuotedPrintable","mimeWord","undefined","decodeQuotedPrintable","toUpperCase","trim","decodedString","encodeBase64","decodeBase64","parseAddresses","addresses","concat","apply","map","address","name","group","forEach","groupAddress","parseHeaders","headers","parseHeaderLines","parseHeaderLine","line","result","parts","split","pos","i","len","length","indexOf","substr","toLowerCase","mimeEncode","toCharset","fromCharset","buffer","ranges","checkRanges","String","fromCharCode","mimeDecode","encodedBytesCount","match","bufferLength","chr","hex","Buffer","bufferPos","charAt","test","parseInt","charCodeAt","addSoftLinebreaks","replace","mimeEncodedStr","spaces","encodedStr","code","splitEncodedString","join","RegExp","curCharset","bind","lineLengthMax","Math","floor","value","decodedValue","encodedValue","encodeHeaderLine","key","lines","headersObj","header","splice","decodeHeaderLine","push","maxlen","curLine","done","index","addQPSoftLinebreaks","base64EncodedStr","nr"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar convert = require(\"encoding\").convert,\n    addressparser = require(\"addressparser\");\n\n/**\n * Folds a long line according to the RFC 5322 http://tools.ietf.org/html/rfc5322#section-2.1.1\n *\n * @param {String} str Mime string that might need folding\n * @param {Number} [maxLength=76] max length for a line\n * @param {Boolean} [foldAnywhere] If true, can fold at any location (ie. in base64)\n * @param {Boolean} [afterSpace] If true fold after the space (default is before)\n * @return {String} Folded string\n */\nmodule.exports.foldLine = function(str, maxLength, foldAnywhere, afterSpace, lineMargin) {\n    if (foldAnywhere) {\n        return addBase64SoftLinebreaks(str, maxLength || 76);\n    }\n    return module.exports.mimeFunctions.foldLine(str, maxLength, !! afterSpace, lineMargin);\n};\n\n/**\n * Encodes a string into mime encoded word format http://en.wikipedia.org/wiki/MIME#Encoded-Word\n *\n * @param {String} str String to be encoded\n * @param {String} encoding Encoding Q for quoted printable or B for base64\n * @param {String} [charset=\"UTF-8\"] Charset to be used\n * @param {Number} [maxLength] If set, split on maxLength\n * @return {String} Mime word encoded string\n */\nmodule.exports.encodeMimeWord = function(str, encoding, charset, maxLength) {\n    return module.exports.mimeFunctions.encodeMimeWord(str, encoding, maxLength || 0, charset);\n};\n\n/**\n * Encodes need parts of a string to mime word format\n *\n * @param {String} str String to be encoded\n * @param {String} encoding Encoding Q for quoted printable or B for base64\n * @param {Number} [maxLength] If set, split on maxLength\n * @param {String} [charset=\"UTF-8\"] Charset to be used\n * @return {String} String with possible mime word encoded parts\n */\nmodule.exports.encodeMimeWords = function(str, encoding, maxLength, charset) {\n    return module.exports.mimeFunctions.encodeMimeWords(str, encoding, maxLength || 0, charset);\n};\n\n/**\n * Decodes a string from mime encoded word\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded string\n */\nmodule.exports.decodeMimeWord = function(str) {\n    return module.exports.mimeFunctions.decodeMimeWord(str).toString(\"utf-8\");\n};\n\n/**\n * Decodes all mime words from a string to an unencoded string\n *\n * @param {String} str String that may include mime words\n * @return {String} Unencoded string\n */\nmodule.exports.parseMimeWords = function(str) {\n    return module.exports.mimeFunctions.decodeMimeWords(str).toString(\"utf-8\");\n};\n\n/**\n * Encodes a string into Quoted-printable format. Maximum line length for the\n * encoded string is always 76+2 bytes\n *\n * @param {String} str String to be encoded into Quoted-printable\n * @param {Boolean} [mimeWord] legacy parameter, not used\n * @param {String} [charset=\"UTF-8\"] Destination charset\n * @return {String} Quoted printable encoded string\n */\nmodule.exports.encodeQuotedPrintable = function(str, mimeWord, charset) {\n    if (typeof mimeWord == \"string\" && !charset) {\n        charset = mimeWord;\n        mimeWord = undefined;\n    }\n    return module.exports.mimeFunctions.encodeQuotedPrintable(str, charset);\n};\n\n/**\n * Decodes a string from Quoted-printable format\n *\n * @param {String} str String to be decoded from Quoted-printable\n * @param {Boolean} [mimeWord] legacy parameter, not used\n * @param {String} [charset=\"UTF-8\"] Source charset\n * @return {String} Decoded string\n */\nmodule.exports.decodeQuotedPrintable = function(str, mimeWord, charset) {\n    if (typeof mimeWord == \"string\" && !charset) {\n        charset = mimeWord;\n        mimeWord = undefined;\n    }\n    charset = (charset || \"\").toString().toUpperCase().trim();\n    var decodedString = module.exports.mimeFunctions.decodeQuotedPrintable(str, \"utf-8\", charset);\n    return charset == \"BINARY\" ? decodedString : decodedString.toString(\"utf-8\");\n};\n\n/**\n * Encodes a string into Base64 format. Base64 is mime-word safe\n *\n * @param {String} str String to be encoded into Base64\n * @param {String} [charset=\"UTF-8\"] Destination charset\n * @return {String} Base64 encoded string\n */\nmodule.exports.encodeBase64 = function(str, charset) {\n    return module.exports.mimeFunctions.encodeBase64(str, charset);\n};\n\n/**\n * Decodes a string from Base64 format\n *\n * @param {String} str String to be decoded from Base64\n * @param {String} [charset=\"UTF-8\"] Source charset\n * @return {String} Decoded string\n */\nmodule.exports.decodeBase64 = function(str, charset) {\n    return module.exports.mimeFunctions.decodeBase64(str, \"utf-8\", charset).toString(\"utf-8\");\n};\n\n/**\n * Parses names and addresses from a from, to, cc or bcc line\n * For example: 'Andris Reinman <andris@tr.ee>, someone@else.com'\n * will be parsed into: [{name:\"Andris Reinman\", address:\"andris@tr.ee\"}, {address: \"someone@else.com\"}]\n *\n * @param {String|Array} addresses Address line string or an array of strings\n * @return {Array} An array of parsed e-mails addresses in the form of [{name, address}]\n */\nmodule.exports.parseAddresses = function(addresses) {\n    return [].concat.apply([], [].concat(addresses).map(addressparser)).map(function(address) {\n        address.name = module.exports.parseMimeWords(address.name);\n        if (address.group) {\n            address.group.forEach(function(groupAddress) {\n                groupAddress.name = module.exports.parseMimeWords(groupAddress.name);\n            });\n        }\n        return address;\n    });\n};\n\n/**\n * Parses header lines into an array of objects. Output: {'x-header': ['value']}\n *\n * @param {String} headers Full header part to be parsed\n * @return {Object} Parsed headers\n */\nmodule.exports.parseHeaders = function(headers) {\n    return module.exports.mimeFunctions.parseHeaderLines(headers);\n};\n\n/**\n * Parses a header line to search for additional parameters. For example\n *     parseHeaderLine('text/plain; charset=utf-8')\n * will be parsed into\n *     {defaultValue: 'text/plain', charset: 'utf-8'}\n *\n * @param {String} line Single header value without key part to be parsed\n * @return {Object} Parsed value\n */\nmodule.exports.parseHeaderLine = function(line) {\n    if (!line) {\n        return {};\n    }\n\n    var result = {}, parts = line.split(\";\"),\n        pos;\n\n    for (var i = 0, len = parts.length; i < len; i++) {\n        pos = parts[i].indexOf(\"=\");\n        if (pos < 0) {\n            result[!i ? \"defaultValue\" : \"i-\" + i] = parts[i].trim();\n        } else {\n            result[parts[i].substr(0, pos).trim().toLowerCase()] = parts[i].substr(pos + 1).trim();\n        }\n    }\n    return result;\n};\n\nmodule.exports.mimeFunctions = {\n\n    mimeEncode: function(str, toCharset, fromCharset) {\n        toCharset = toCharset || \"UTF-8\";\n        fromCharset = fromCharset || \"UTF-8\";\n\n        var buffer = convert(str || \"\", toCharset, fromCharset),\n            ranges = [\n                [0x09],\n                [0x0A],\n                [0x0D],\n                [0x20],\n                [0x21],\n                [0x23, 0x3C],\n                [0x3E],\n                [0x40, 0x5E],\n                [0x60, 0x7E]\n            ],\n            result = \"\";\n\n        for (var i = 0, len = buffer.length; i < len; i++) {\n            if (checkRanges(buffer[i], ranges)) {\n                result += String.fromCharCode(buffer[i]);\n                continue;\n            }\n            result += \"=\" + (buffer[i] < 0x10 ? \"0\" : \"\") + buffer[i].toString(16).toUpperCase();\n        }\n\n        return result;\n    },\n\n    mimeDecode: function(str, toCharset, fromCharset) {\n        str = (str || \"\").toString();\n        toCharset = toCharset || \"UTF-8\";\n        fromCharset = fromCharset || \"UTF-8\";\n\n        var encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n            bufferLength = str.length - encodedBytesCount * 2,\n            chr, hex,\n            buffer = new Buffer(bufferLength),\n            bufferPos = 0;\n\n        for (var i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (chr == \"=\" && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n                buffer[bufferPos++] = parseInt(hex, 16);\n                i += 2;\n                continue;\n            }\n            buffer[bufferPos++] = chr.charCodeAt(0);\n        }\n\n        if (fromCharset.toUpperCase().trim() == \"BINARY\") {\n            return buffer;\n        }\n        return convert(buffer, toCharset, fromCharset);\n    },\n\n    encodeBase64: function(str, toCharset, fromCharset) {\n        var buffer = convert(str || \"\", toCharset, fromCharset);\n        return addSoftLinebreaks(buffer.toString(\"base64\"), \"base64\");\n    },\n\n    decodeBase64: function(str, toCharset, fromCharset) {\n        var buffer = new Buffer((str || \"\").toString(), \"base64\");\n        return convert(buffer, toCharset, fromCharset);\n    },\n\n    decodeQuotedPrintable: function(str, toCharset, fromCharset) {\n        str = (str || \"\").toString();\n        str = str.replace(/\\=(?:\\r?\\n|$)/g, \"\");\n        return this.mimeDecode(str, toCharset, fromCharset);\n    },\n\n    encodeQuotedPrintable: function(str, toCharset, fromCharset) {\n        var mimeEncodedStr = this.mimeEncode(str, toCharset, fromCharset);\n\n        // fix line breaks\n        mimeEncodedStr = mimeEncodedStr.replace(/\\r?\\n|\\r/g, function() {\n            return \"\\r\\n\";\n        }).replace(/[\\t ]+$/gm, function(spaces) {\n            return spaces.replace(/ /g, \"=20\").replace(/\\t/g, \"=09\");\n        });\n\n        return addSoftLinebreaks(mimeEncodedStr, \"qp\");\n    },\n\n    encodeMimeWord: function(str, encoding, maxLength, toCharset, fromCharset) {\n        toCharset = (toCharset || \"utf-8\").toString().toUpperCase().trim();\n        encoding = (encoding || \"Q\").toString().toUpperCase().trim().charAt(0);\n        var encodedStr;\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= (7 + toCharset.length);\n        }\n\n        if (encoding == \"Q\") {\n            encodedStr = this.mimeEncode(str, toCharset, fromCharset);\n            encodedStr = encodedStr.replace(/[\\r\\n\\t_]/g, function(chr) {\n                var code = chr.charCodeAt(0);\n                return \"=\" + (code < 0x10 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n            }).replace(/\\s/g, \"_\");\n        } else if (encoding == \"B\") {\n            encodedStr = convert(str || \"\", toCharset, fromCharset).toString(\"base64\").trim();\n        }\n\n        if (maxLength && encodedStr.length > maxLength) {\n            if (encoding == \"Q\") {\n                encodedStr = this.splitEncodedString(encodedStr, maxLength).join(\"?= =?\" + toCharset + \"?\" + encoding + \"?\");\n            } else {\n                encodedStr = encodedStr.replace(new RegExp(\".{\" + maxLength + \"}\", \"g\"), \"$&?= =?\" + toCharset + \"?\" + encoding + \"?\");\n                if (encodedStr.substr(-(\" =?\" + toCharset + \"?\" + encoding + \"?=\").length) == \" =?\" + toCharset + \"?\" + encoding + \"?=\") {\n                    encodedStr = encodedStr.substr(0, encodedStr.length - (\" =?\" + toCharset + \"?\" + encoding + \"?=\").length);\n                }\n                if (encodedStr.substr(-(\" =?\" + toCharset + \"?\" + encoding + \"?\").length) == \" =?\" + toCharset + \"?\" + encoding + \"?\") {\n                    encodedStr = encodedStr.substr(0, encodedStr.length - (\" =?\" + toCharset + \"?\" + encoding + \"?\").length);\n                }\n            }\n        }\n\n        return \"=?\" + toCharset + \"?\" + encoding + \"?\" + encodedStr + (encodedStr.substr(-2) == \"?=\" ? \"\" : \"?=\");\n    },\n\n    decodeMimeWord: function(str, toCharset) {\n        str = (str || \"\").toString().trim();\n\n        var fromCharset, encoding, match;\n\n        match = str.match(/^\\=\\?([\\w_\\-]+)\\?([QqBb])\\?([^\\?]*)\\?\\=$/i);\n        if (!match) {\n            return convert(str, toCharset);\n        }\n\n        fromCharset = match[1];\n        encoding = (match[2] || \"Q\").toString().toUpperCase();\n        str = (match[3] || \"\").replace(/_/g, \" \");\n\n        if (encoding == \"B\") {\n            return this.decodeBase64(str, toCharset, fromCharset);\n        } else if (encoding == \"Q\") {\n            return this.mimeDecode(str, toCharset, fromCharset);\n        } else {\n            return str;\n        }\n\n\n    },\n\n    decodeMimeWords: function(str, toCharset) {\n        var curCharset;\n\n        str = (str || \"\").toString().\n        replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, \"$1\").\n        replace(/\\=\\?([\\w_\\-]+)\\?([QqBb])\\?[^\\?]*\\?\\=/g, (function(mimeWord, charset, encoding) {\n            curCharset = charset + encoding;\n            return this.decodeMimeWord(mimeWord);\n        }).bind(this));\n\n        return convert(str, toCharset);\n    },\n\n    foldLine: function(str, lineLengthMax, afterSpace, lineMargin) {\n        lineLengthMax = lineLengthMax || 76;\n        lineMargin = lineMargin || Math.floor(lineLengthMax / 5);\n        str = (str || \"\").toString().trim();\n\n        var pos = 0,\n            len = str.length,\n            result = \"\",\n            line, match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLengthMax);\n            if (line.length < lineLengthMax) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.substr(-lineMargin).match(/(\\s+)[^\\s]*$/))) {\n                line = line.substr(0, line.length - (match[0].length - ( !! afterSpace ? (match[1] || \"\").length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || \"\").length : 0));\n            }\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += \"\\r\\n\";\n            }\n        }\n\n        return result;\n    },\n\n    encodeMimeWords: function(value, encoding, maxLength, toCharset, fromCharset) {\n        var decodedValue = convert((value || \"\"), \"utf-8\", fromCharset).toString(\"utf-8\"),\n            encodedValue;\n\n        encodedValue = decodedValue.replace(/([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g, (function(str) {\n            return str.length ? this.encodeMimeWord(str, encoding || \"Q\", maxLength, toCharset) : \"\";\n        }).bind(this));\n\n        return encodedValue;\n    },\n\n    encodeHeaderLine: function(key, value, toCharset, fromCharset) {\n        var encodedValue = this.encodeMimeWords(value, 52, toCharset, fromCharset);\n        return this.foldLine(key + \": \" + encodedValue, 76);\n    },\n\n    parseHeaderLines: function(headers, toCharset) {\n        var lines = headers.split(/\\r?\\n|\\r/),\n            headersObj = {},\n            key, value,\n            header,\n            i, len;\n\n        for (i = lines.length - 1; i >= 0; i--) {\n            if (i && lines[i].match(/^\\s/)) {\n                lines[i - 1] += \"\\r\\n\" + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n\n        for (i = 0, len = lines.length; i < len; i++) {\n            header = this.decodeHeaderLine(lines[i]);\n            key = (header[0] || \"\").toString().toLowerCase().trim();\n            value = header[1] || \"\";\n            if (!toCharset || (toCharset || \"\").toString().trim().match(/^utf[\\-_]?8$/i)) {\n                value = value.toString(\"utf-8\");\n            }\n            if (!headersObj[key]) {\n                headersObj[key] = [value];\n            } else {\n                headersObj[key].push(value);\n            }\n        }\n\n        return headersObj;\n    },\n\n    decodeHeaderLine: function(header, toCharset) {\n        var line = (header || \"\").toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, \" \").trim(),\n            match = line.match(/^\\s*([^:]+):(.*)$/),\n            key = (match && match[1] || \"\").trim(),\n            value = (match && match[2] || \"\").trim();\n\n        value = this.decodeMimeWords(value, toCharset);\n        return [key, value];\n    },\n\n    splitEncodedString: function(str, maxlen) {\n        var curLine, match, chr, done,\n            lines = [];\n\n        while (str.length) {\n            curLine = str.substr(0, maxlen);\n\n            // move incomplete escaped char back to main\n            if ((match = curLine.match(/\\=[0-9A-F]?$/i))) {\n                curLine = curLine.substr(0, match.index);\n            }\n\n            done = false;\n            while (!done) {\n                done = true;\n                // check if not middle of a unicode char sequence\n                if ((match = str.substr(curLine.length).match(/^\\=([0-9A-F]{2})/i))) {\n                    chr = parseInt(match[1], 16);\n                    // invalid sequence, move one char back anc recheck\n                    if (chr < 0xC2 && chr > 0x7F) {\n                        curLine = curLine.substr(0, curLine.length - 3);\n                        done = false;\n                    }\n                }\n            }\n\n            if (curLine.length) {\n                lines.push(curLine);\n            }\n            str = str.substr(curLine.length);\n        }\n\n        return lines;\n    },\n\n    parseAddresses: addressparser\n\n};\n\n// Lines can't be longer that 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\nfunction addSoftLinebreaks(str, encoding) {\n    var lineLengthMax = 76;\n\n    encoding = (encoding || \"base64\").toString().toLowerCase().trim();\n\n    if (encoding == \"qp\") {\n        return addQPSoftLinebreaks(str, lineLengthMax);\n    } else {\n        return addBase64SoftLinebreaks(str, lineLengthMax);\n    }\n}\n\nfunction addBase64SoftLinebreaks(base64EncodedStr, lineLengthMax) {\n    base64EncodedStr = (base64EncodedStr || \"\").toString().trim();\n    return base64EncodedStr.replace(new RegExp(\".{\" + lineLengthMax + \"}\", \"g\"), \"$&\\r\\n\").trim();\n}\n\nfunction addQPSoftLinebreaks(mimeEncodedStr, lineLengthMax) {\n    var pos = 0,\n        len = mimeEncodedStr.length,\n        match, code, line,\n        lineMargin = Math.floor(lineLengthMax / 3),\n        result = \"\";\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = mimeEncodedStr.substr(pos, lineLengthMax);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) == \"\\n\") {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLengthMax - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.substr(-1) == \"\\r\") {\n            line = line.substr(0, line.length - 1);\n        } else {\n            if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n\n                // push incomplete encoding sequences to the next line\n                if ((match = line.match(/\\=[\\da-f]{0,1}$/i))) {\n                    line = line.substr(0, line.length - match[0].length);\n                }\n\n                // ensure that utf-8 sequences are not split\n                while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/ig))) {\n                    code = parseInt(match[0].substr(1, 2), 16);\n                    if (code < 128) {\n                        break;\n                    }\n\n                    line = line.substr(0, line.length - 3);\n\n                    if (code >= 0xC0) {\n                        break;\n                    }\n                }\n\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) != \"\\n\") {\n            if (line.length == 76 && line.match(/\\=[\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length == 76) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += \"=\\r\\n\";\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\nfunction checkRanges(nr, ranges) {\n    for (var i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length == 1 && nr == ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length == 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var utils = require('./utils');\n/**\n * A lexer token.\n * @typedef {object} LexerToken\n * @property {string} match  The string that was matched.\n * @property {number} type   Lexer type enum.\n * @property {number} length Length of the original string processed.\n */\n\n/**\n * Enum for token types.\n * @readonly\n * @enum {number}\n */\n\n\nvar TYPES = {\n  /** Whitespace */\n  WHITESPACE: 0,\n\n  /** Plain string */\n  STRING: 1,\n\n  /** Variable filter */\n  FILTER: 2,\n\n  /** Empty variable filter */\n  FILTEREMPTY: 3,\n\n  /** Function */\n  FUNCTION: 4,\n\n  /** Function with no arguments */\n  FUNCTIONEMPTY: 5,\n\n  /** Open parenthesis */\n  PARENOPEN: 6,\n\n  /** Close parenthesis */\n  PARENCLOSE: 7,\n\n  /** Comma */\n  COMMA: 8,\n\n  /** Variable */\n  VAR: 9,\n\n  /** Number */\n  NUMBER: 10,\n\n  /** Math operator */\n  OPERATOR: 11,\n\n  /** Open square bracket */\n  BRACKETOPEN: 12,\n\n  /** Close square bracket */\n  BRACKETCLOSE: 13,\n\n  /** Key on an object using dot-notation */\n  DOTKEY: 14,\n\n  /** Start of an array */\n  ARRAYOPEN: 15,\n\n  /** End of an array\n   * Currently unused\n  ARRAYCLOSE: 16, */\n\n  /** Open curly brace */\n  CURLYOPEN: 17,\n\n  /** Close curly brace */\n  CURLYCLOSE: 18,\n\n  /** Colon (:) */\n  COLON: 19,\n\n  /** JavaScript-valid comparator */\n  COMPARATOR: 20,\n\n  /** Boolean logic */\n  LOGIC: 21,\n\n  /** Boolean logic \"not\" */\n  NOT: 22,\n\n  /** true or false */\n  BOOL: 23,\n\n  /** Variable assignment */\n  ASSIGNMENT: 24,\n\n  /** Start of a method */\n  METHODOPEN: 25,\n\n  /** End of a method\n   * Currently unused\n  METHODEND: 26, */\n\n  /** Unknown type */\n  UNKNOWN: 100\n},\n    rules = [{\n  type: TYPES.WHITESPACE,\n  regex: [/^\\s+/]\n}, {\n  type: TYPES.STRING,\n  regex: [/^\"\"/, /^\".*?[^\\\\]\"/, /^''/, /^'.*?[^\\\\]'/]\n}, {\n  type: TYPES.FILTER,\n  regex: [/^\\|\\s*(\\w+)\\(/],\n  idx: 1\n}, {\n  type: TYPES.FILTEREMPTY,\n  regex: [/^\\|\\s*(\\w+)/],\n  idx: 1\n}, {\n  type: TYPES.FUNCTIONEMPTY,\n  regex: [/^\\s*(\\w+)\\(\\)/],\n  idx: 1\n}, {\n  type: TYPES.FUNCTION,\n  regex: [/^\\s*(\\w+)\\(/],\n  idx: 1\n}, {\n  type: TYPES.PARENOPEN,\n  regex: [/^\\(/]\n}, {\n  type: TYPES.PARENCLOSE,\n  regex: [/^\\)/]\n}, {\n  type: TYPES.COMMA,\n  regex: [/^,/]\n}, {\n  type: TYPES.LOGIC,\n  regex: [/^(&&|\\|\\|)\\s*/, /^(and|or)\\s+/],\n  idx: 1,\n  replace: {\n    'and': '&&',\n    'or': '||'\n  }\n}, {\n  type: TYPES.COMPARATOR,\n  regex: [/^(===|==|\\!==|\\!=|<=|<|>=|>|in\\s|gte\\s|gt\\s|lte\\s|lt\\s)\\s*/],\n  idx: 1,\n  replace: {\n    'gte': '>=',\n    'gt': '>',\n    'lte': '<=',\n    'lt': '<'\n  }\n}, {\n  type: TYPES.ASSIGNMENT,\n  regex: [/^(=|\\+=|-=|\\*=|\\/=)/]\n}, {\n  type: TYPES.NOT,\n  regex: [/^\\!\\s*/, /^not\\s+/],\n  replace: {\n    'not': '!'\n  }\n}, {\n  type: TYPES.BOOL,\n  regex: [/^(true|false)\\s+/, /^(true|false)$/],\n  idx: 1\n}, {\n  type: TYPES.VAR,\n  regex: [/^[a-zA-Z_$]\\w*((\\.\\$?\\w*)+)?/, /^[a-zA-Z_$]\\w*/]\n}, {\n  type: TYPES.BRACKETOPEN,\n  regex: [/^\\[/]\n}, {\n  type: TYPES.BRACKETCLOSE,\n  regex: [/^\\]/]\n}, {\n  type: TYPES.CURLYOPEN,\n  regex: [/^\\{/]\n}, {\n  type: TYPES.COLON,\n  regex: [/^\\:/]\n}, {\n  type: TYPES.CURLYCLOSE,\n  regex: [/^\\}/]\n}, {\n  type: TYPES.DOTKEY,\n  regex: [/^\\.(\\w+)/],\n  idx: 1\n}, {\n  type: TYPES.NUMBER,\n  regex: [/^[+\\-]?\\d+(\\.\\d+)?/]\n}, {\n  type: TYPES.OPERATOR,\n  regex: [/^(\\+|\\-|\\/|\\*|%)/]\n}];\nexports.types = TYPES;\n/**\n * Return the token type object for a single chunk of a string.\n * @param  {string} str String chunk.\n * @return {LexerToken}     Defined type, potentially stripped or replaced with more suitable content.\n * @private\n */\n\nfunction reader(str) {\n  var matched;\n  utils.some(rules, function (rule) {\n    return utils.some(rule.regex, function (regex) {\n      var match = str.match(regex),\n          normalized;\n\n      if (!match) {\n        return;\n      }\n\n      normalized = match[rule.idx || 0].replace(/\\s*$/, '');\n      normalized = rule.hasOwnProperty('replace') && rule.replace.hasOwnProperty(normalized) ? rule.replace[normalized] : normalized;\n      matched = {\n        match: normalized,\n        type: rule.type,\n        length: match[0].length\n      };\n      return true;\n    });\n  });\n\n  if (!matched) {\n    matched = {\n      match: str,\n      type: TYPES.UNKNOWN,\n      length: str.length\n    };\n  }\n\n  return matched;\n}\n/**\n * Read a string and break it into separate token types.\n * @param  {string} str\n * @return {Array.LexerToken}     Array of defined types, potentially stripped or replaced with more suitable content.\n * @private\n */\n\n\nexports.read = function (str) {\n  var offset = 0,\n      tokens = [],\n      substr,\n      match;\n\n  while (offset < str.length) {\n    substr = str.substring(offset);\n    match = reader(substr);\n    offset += match.length;\n    tokens.push(match);\n  }\n\n  return tokens;\n};","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/swig/lib/lexer.js"],"names":["utils","require","TYPES","WHITESPACE","STRING","FILTER","FILTEREMPTY","FUNCTION","FUNCTIONEMPTY","PARENOPEN","PARENCLOSE","COMMA","VAR","NUMBER","OPERATOR","BRACKETOPEN","BRACKETCLOSE","DOTKEY","ARRAYOPEN","CURLYOPEN","CURLYCLOSE","COLON","COMPARATOR","LOGIC","NOT","BOOL","ASSIGNMENT","METHODOPEN","UNKNOWN","rules","type","regex","idx","replace","exports","types","reader","str","matched","some","rule","match","normalized","hasOwnProperty","length","read","offset","tokens","substr","substring","push"],"mappings":"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","sourcesContent":["var utils = require('./utils');\n\n/**\n * A lexer token.\n * @typedef {object} LexerToken\n * @property {string} match  The string that was matched.\n * @property {number} type   Lexer type enum.\n * @property {number} length Length of the original string processed.\n */\n\n/**\n * Enum for token types.\n * @readonly\n * @enum {number}\n */\nvar TYPES = {\n    /** Whitespace */\n    WHITESPACE: 0,\n    /** Plain string */\n    STRING: 1,\n    /** Variable filter */\n    FILTER: 2,\n    /** Empty variable filter */\n    FILTEREMPTY: 3,\n    /** Function */\n    FUNCTION: 4,\n    /** Function with no arguments */\n    FUNCTIONEMPTY: 5,\n    /** Open parenthesis */\n    PARENOPEN: 6,\n    /** Close parenthesis */\n    PARENCLOSE: 7,\n    /** Comma */\n    COMMA: 8,\n    /** Variable */\n    VAR: 9,\n    /** Number */\n    NUMBER: 10,\n    /** Math operator */\n    OPERATOR: 11,\n    /** Open square bracket */\n    BRACKETOPEN: 12,\n    /** Close square bracket */\n    BRACKETCLOSE: 13,\n    /** Key on an object using dot-notation */\n    DOTKEY: 14,\n    /** Start of an array */\n    ARRAYOPEN: 15,\n    /** End of an array\n     * Currently unused\n    ARRAYCLOSE: 16, */\n    /** Open curly brace */\n    CURLYOPEN: 17,\n    /** Close curly brace */\n    CURLYCLOSE: 18,\n    /** Colon (:) */\n    COLON: 19,\n    /** JavaScript-valid comparator */\n    COMPARATOR: 20,\n    /** Boolean logic */\n    LOGIC: 21,\n    /** Boolean logic \"not\" */\n    NOT: 22,\n    /** true or false */\n    BOOL: 23,\n    /** Variable assignment */\n    ASSIGNMENT: 24,\n    /** Start of a method */\n    METHODOPEN: 25,\n    /** End of a method\n     * Currently unused\n    METHODEND: 26, */\n    /** Unknown type */\n    UNKNOWN: 100\n  },\n  rules = [\n    {\n      type: TYPES.WHITESPACE,\n      regex: [\n        /^\\s+/\n      ]\n    },\n    {\n      type: TYPES.STRING,\n      regex: [\n        /^\"\"/,\n        /^\".*?[^\\\\]\"/,\n        /^''/,\n        /^'.*?[^\\\\]'/\n      ]\n    },\n    {\n      type: TYPES.FILTER,\n      regex: [\n        /^\\|\\s*(\\w+)\\(/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.FILTEREMPTY,\n      regex: [\n        /^\\|\\s*(\\w+)/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.FUNCTIONEMPTY,\n      regex: [\n        /^\\s*(\\w+)\\(\\)/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.FUNCTION,\n      regex: [\n        /^\\s*(\\w+)\\(/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.PARENOPEN,\n      regex: [\n        /^\\(/\n      ]\n    },\n    {\n      type: TYPES.PARENCLOSE,\n      regex: [\n        /^\\)/\n      ]\n    },\n    {\n      type: TYPES.COMMA,\n      regex: [\n        /^,/\n      ]\n    },\n    {\n      type: TYPES.LOGIC,\n      regex: [\n        /^(&&|\\|\\|)\\s*/,\n        /^(and|or)\\s+/\n      ],\n      idx: 1,\n      replace: {\n        'and': '&&',\n        'or': '||'\n      }\n    },\n    {\n      type: TYPES.COMPARATOR,\n      regex: [\n        /^(===|==|\\!==|\\!=|<=|<|>=|>|in\\s|gte\\s|gt\\s|lte\\s|lt\\s)\\s*/\n      ],\n      idx: 1,\n      replace: {\n        'gte': '>=',\n        'gt': '>',\n        'lte': '<=',\n        'lt': '<'\n      }\n    },\n    {\n      type: TYPES.ASSIGNMENT,\n      regex: [\n        /^(=|\\+=|-=|\\*=|\\/=)/\n      ]\n    },\n    {\n      type: TYPES.NOT,\n      regex: [\n        /^\\!\\s*/,\n        /^not\\s+/\n      ],\n      replace: {\n        'not': '!'\n      }\n    },\n    {\n      type: TYPES.BOOL,\n      regex: [\n        /^(true|false)\\s+/,\n        /^(true|false)$/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.VAR,\n      regex: [\n        /^[a-zA-Z_$]\\w*((\\.\\$?\\w*)+)?/,\n        /^[a-zA-Z_$]\\w*/\n      ]\n    },\n    {\n      type: TYPES.BRACKETOPEN,\n      regex: [\n        /^\\[/\n      ]\n    },\n    {\n      type: TYPES.BRACKETCLOSE,\n      regex: [\n        /^\\]/\n      ]\n    },\n    {\n      type: TYPES.CURLYOPEN,\n      regex: [\n        /^\\{/\n      ]\n    },\n    {\n      type: TYPES.COLON,\n      regex: [\n        /^\\:/\n      ]\n    },\n    {\n      type: TYPES.CURLYCLOSE,\n      regex: [\n        /^\\}/\n      ]\n    },\n    {\n      type: TYPES.DOTKEY,\n      regex: [\n        /^\\.(\\w+)/\n      ],\n      idx: 1\n    },\n    {\n      type: TYPES.NUMBER,\n      regex: [\n        /^[+\\-]?\\d+(\\.\\d+)?/\n      ]\n    },\n    {\n      type: TYPES.OPERATOR,\n      regex: [\n        /^(\\+|\\-|\\/|\\*|%)/\n      ]\n    }\n  ];\n\nexports.types = TYPES;\n\n/**\n * Return the token type object for a single chunk of a string.\n * @param  {string} str String chunk.\n * @return {LexerToken}     Defined type, potentially stripped or replaced with more suitable content.\n * @private\n */\nfunction reader(str) {\n  var matched;\n\n  utils.some(rules, function (rule) {\n    return utils.some(rule.regex, function (regex) {\n      var match = str.match(regex),\n        normalized;\n\n      if (!match) {\n        return;\n      }\n\n      normalized = match[rule.idx || 0].replace(/\\s*$/, '');\n      normalized = (rule.hasOwnProperty('replace') && rule.replace.hasOwnProperty(normalized)) ? rule.replace[normalized] : normalized;\n\n      matched = {\n        match: normalized,\n        type: rule.type,\n        length: match[0].length\n      };\n      return true;\n    });\n  });\n\n  if (!matched) {\n    matched = {\n      match: str,\n      type: TYPES.UNKNOWN,\n      length: str.length\n    };\n  }\n\n  return matched;\n}\n\n/**\n * Read a string and break it into separate token types.\n * @param  {string} str\n * @return {Array.LexerToken}     Array of defined types, potentially stripped or replaced with more suitable content.\n * @private\n */\nexports.read = function (str) {\n  var offset = 0,\n    tokens = [],\n    substr,\n    match;\n  while (offset < str.length) {\n    substr = str.substring(offset);\n    match = reader(substr);\n    offset += match.length;\n    tokens.push(match);\n  }\n  return tokens;\n};\n"]},"metadata":{},"sourceType":"script"}
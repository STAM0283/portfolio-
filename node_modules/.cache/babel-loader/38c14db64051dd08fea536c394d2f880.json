{"ast":null,"code":"'use strict';\n\nvar simplesmtp = require('../index'),\n    EventEmitter = require('events').EventEmitter,\n    utillib = require('util'),\n    xoauth2 = require('xoauth2'); // expose to the world\n\n\nmodule.exports = function (port, host, options) {\n  var pool = new SMTPConnectionPool(port, host, options);\n  return pool;\n};\n/**\n * <p>Creates a SMTP connection pool</p>\n *\n * <p>Optional options object takes the following possible properties:</p>\n * <ul>\n *     <li><b>secureConnection</b> - use SSL</li>\n *     <li><b>name</b> - the name of the client server</li>\n *     <li><b>auth</b> - authentication object <code>{user:'...', pass:'...'}</code>\n *     <li><b>ignoreTLS</b> - ignore server support for STARTTLS</li>\n *     <li><b>tls</b> - options for createCredentials</li>\n *     <li><b>debug</b> - output client and server messages to console</li>\n *     <li><b>maxConnections</b> - how many connections to keep in the pool</li>\n * </ul>\n *\n * @constructor\n * @namespace SMTP Client Pool module\n * @param {Number} [port=25] The port number to connecto to\n * @param {String} [host='localhost'] THe hostname to connect to\n * @param {Object} [options] optional options object\n */\n\n\nfunction SMTPConnectionPool(port, host, options) {\n  EventEmitter.call(this);\n  /**\n   * Port number to connect to\n   * @public\n   */\n\n  this.port = port || 25;\n  /**\n   * Hostname to connect to\n   * @public\n   */\n\n  this.host = host || 'localhost';\n  /**\n   * Options object\n   * @public\n   */\n\n  this.options = options || {};\n  this.options.maxConnections = this.options.maxConnections || 5;\n  this.options.maxMessages = this.options.maxMessages || Infinity;\n  /**\n   * An array of connections that are currently idle\n   * @private\n   */\n\n  this._connectionsAvailable = [];\n  /**\n   * An array of connections that are currently in use\n   * @private\n   */\n\n  this._connectionsInUse = [];\n  /**\n   * Message queue (FIFO)\n   * @private\n   */\n\n  this._messageQueue = [];\n  /**\n   * Counter for generating ID values for debugging\n   * @private\n   */\n\n  this._idgen = 0; // Initialize XOAUTH2 if needed\n\n  if (this.options.auth && typeof this.options.auth.XOAuth2 == 'object') {\n    if (!this.options.auth.XOAuth2.user && this.options.auth.user) {\n      this.options.auth.XOAuth2.user = this.options.auth.user;\n    }\n\n    this.options.auth.XOAuth2 = xoauth2.createXOAuth2Generator(this.options.auth.XOAuth2);\n  }\n}\n\nutillib.inherits(SMTPConnectionPool, EventEmitter);\n/**\n * <p>Sends a message. If there's any idling connections available\n * use one to send the message immediatelly, otherwise add to queue.</p>\n *\n * @param {Object} message MailComposer object\n * @param {Function} callback Callback function to run on finish, gets an\n *        <code>error</code> object as a parameter if the sending failed\n *        and on success an object with <code>failedRecipients</code> array as\n *        a list of addresses that were rejected (if any) and\n *        <code>message</code> which indicates the last message received from\n *        the server\n */\n\nSMTPConnectionPool.prototype.sendMail = function (message, callback) {\n  var connection;\n  message.returnCallback = callback;\n\n  if (this._connectionsAvailable.length) {\n    // if available connections pick one\n    connection = this._connectionsAvailable.pop();\n\n    this._connectionsInUse.push(connection);\n\n    this._processMessage(message, connection);\n  } else {\n    this._messageQueue.push(message);\n\n    if (this._connectionsAvailable.length + this._connectionsInUse.length < this.options.maxConnections) {\n      this._createConnection();\n    }\n  }\n};\n/**\n * <p>Closes all connections</p>\n */\n\n\nSMTPConnectionPool.prototype.close = function (callback) {\n  var connection; // for some reason destroying the connections seem to be the only way :S\n\n  while (this._connectionsAvailable.length) {\n    connection = this._connectionsAvailable.pop();\n    connection.quit();\n  }\n\n  while (this._connectionsInUse.length) {\n    connection = this._connectionsInUse.pop();\n    connection.quit();\n  }\n\n  if (callback) {\n    if (typeof setImmediate == 'function') {\n      setImmediate(callback);\n    } else {\n      process.nextTick(callback);\n    }\n  }\n};\n/**\n * <p>Initiates a connection to the SMTP server and adds it to the pool</p>\n */\n\n\nSMTPConnectionPool.prototype._createConnection = function () {\n  var connectionOptions = {\n    instanceId: ++this._idgen,\n    debug: !!this.options.debug,\n    logFile: this.options.logFile,\n    ignoreTLS: !!this.options.ignoreTLS,\n    tls: this.options.tls || false,\n    auth: this.options.auth || false,\n    authMethod: this.options.authMethod,\n    name: this.options.name || false,\n    secureConnection: !!this.options.secureConnection\n  },\n      connection;\n\n  if ('greetingTimeout' in this.options) {\n    connectionOptions.greetingTimeout = this.options.greetingTimeout;\n  }\n\n  if ('socketTimeout' in this.options) {\n    connectionOptions.socketTimeout = this.options.socketTimeout;\n  }\n\n  if ('connectionTimeout' in this.options) {\n    connectionOptions.connectionTimeout = this.options.connectionTimeout;\n  }\n\n  if ('rejectUnathorized' in this.options) {\n    connectionOptions.rejectUnathorized = this.options.rejectUnathorized;\n  }\n\n  if ('localAddress' in this.options) {\n    connectionOptions.localAddress = this.options.localAddress;\n  }\n\n  connection = simplesmtp.connect(this.port, this.host, connectionOptions);\n  connection._messagesProcessed = 0;\n  connection.on('idle', this._onConnectionIdle.bind(this, connection));\n  connection.on('message', this._onConnectionMessage.bind(this, connection));\n  connection.on('ready', this._onConnectionReady.bind(this, connection));\n  connection.on('error', this._onConnectionError.bind(this, connection));\n  connection.on('end', this._onConnectionEnd.bind(this, connection));\n  connection.on('rcptFailed', this._onConnectionRCPTFailed.bind(this, connection));\n  this.emit('connectionCreated', connection); // as the connection is not ready yet, add to 'in use' queue\n\n  this._connectionsInUse.push(connection);\n};\n/**\n * <p>Processes a message by assigning it to a connection object and initiating\n * the sending process by setting the envelope</p>\n *\n * @param {Object} message MailComposer message object\n * @param {Object} connection <code>simplesmtp.connect</code> connection\n */\n\n\nSMTPConnectionPool.prototype._processMessage = function (message, connection) {\n  connection.currentMessage = message;\n  message.currentConnection = connection;\n  connection._messagesProcessed++; // send envelope\n\n  connection.useEnvelope(message.getEnvelope());\n};\n/**\n * <p>Will be fired on <code>'idle'</code> events by the connection, if\n * there's a message currently in queue</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\n\n\nSMTPConnectionPool.prototype._onConnectionIdle = function (connection) {\n  var message = this._messageQueue.shift();\n\n  if (message) {\n    this._processMessage(message, connection);\n  } else {\n    for (var i = 0, len = this._connectionsInUse.length; i < len; i++) {\n      if (this._connectionsInUse[i] == connection) {\n        this._connectionsInUse.splice(i, 1); // remove from list\n\n\n        break;\n      }\n    }\n\n    this._connectionsAvailable.push(connection);\n  }\n};\n/**\n * <p>Will be called when not all recipients were accepted</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Array} addresses Failed addresses as an array of strings\n */\n\n\nSMTPConnectionPool.prototype._onConnectionRCPTFailed = function (connection, addresses) {\n  if (connection.currentMessage) {\n    connection.currentMessage.failedRecipients = addresses;\n  }\n};\n/**\n * <p>Will be called when the client is waiting for a message to deliver</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\n\n\nSMTPConnectionPool.prototype._onConnectionMessage = function (connection) {\n  if (connection.currentMessage) {\n    connection.currentMessage.streamMessage();\n    connection.currentMessage.pipe(connection);\n  }\n};\n/**\n * <p>Will be called when a message has been delivered</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Boolean} success True if the message was queued by the SMTP server\n * @param {String} message Last message received from the server\n */\n\n\nSMTPConnectionPool.prototype._onConnectionReady = function (connection, success, message) {\n  var error,\n      responseObj = {};\n\n  if (connection._messagesProcessed >= this.options.maxMessages && connection.socket) {\n    connection.emit('end');\n    connection.removeAllListeners();\n\n    if (connection.socket) {\n      connection.socket.destroy();\n    }\n\n    this.emit('released', connection);\n  }\n\n  if (connection.currentMessage && connection.currentMessage.returnCallback) {\n    if (success) {\n      if (connection.currentMessage.failedRecipients) {\n        responseObj.failedRecipients = connection.currentMessage.failedRecipients;\n      }\n\n      if (message) {\n        responseObj.message = message;\n      }\n\n      if (connection.currentMessage._messageId) {\n        responseObj.messageId = connection.currentMessage._messageId;\n      }\n\n      connection.currentMessage.returnCallback(null, responseObj);\n    } else {\n      error = new Error('Message delivery failed' + (message ? ': ' + message : ''));\n      error.name = 'DeliveryError';\n      error.data = message;\n      connection.currentMessage.returnCallback(error);\n    }\n  }\n\n  connection.currentMessage = false;\n};\n/**\n * <p>Will be called when an error occurs</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Object} error Error object\n */\n\n\nSMTPConnectionPool.prototype._onConnectionError = function (connection, error) {\n  var message = connection.currentMessage;\n  connection.currentMessage = false; // clear a first message from the list, otherwise an infinite loop will emerge\n\n  if (!message) {\n    message = this._messageQueue.shift();\n  }\n\n  if (message && message.returnCallback) {\n    message.returnCallback(error);\n  }\n};\n/**\n * <p>Will be called when a connection to the client is closed</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\n\n\nSMTPConnectionPool.prototype._onConnectionEnd = function (connection) {\n  var removed = false,\n      i,\n      len; // if in 'available' list, remove\n\n  for (i = 0, len = this._connectionsAvailable.length; i < len; i++) {\n    if (this._connectionsAvailable[i] == connection) {\n      this._connectionsAvailable.splice(i, 1); // remove from list\n\n\n      removed = true;\n      break;\n    }\n  }\n\n  if (!removed) {\n    // if in 'in use' list, remove\n    for (i = 0, len = this._connectionsInUse.length; i < len; i++) {\n      if (this._connectionsInUse[i] == connection) {\n        this._connectionsInUse.splice(i, 1); // remove from list\n\n\n        removed = true;\n        break;\n      }\n    }\n  } // if there's still unprocessed mail and available connection slots, create\n  // a new connection\n\n\n  if (this._messageQueue.length && this._connectionsInUse.length + this._connectionsAvailable.length < this.options.maxConnections) {\n    this._createConnection();\n  }\n};","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/simplesmtp/lib/pool.js"],"names":["simplesmtp","require","EventEmitter","utillib","xoauth2","module","exports","port","host","options","pool","SMTPConnectionPool","call","maxConnections","maxMessages","Infinity","_connectionsAvailable","_connectionsInUse","_messageQueue","_idgen","auth","XOAuth2","user","createXOAuth2Generator","inherits","prototype","sendMail","message","callback","connection","returnCallback","length","pop","push","_processMessage","_createConnection","close","quit","setImmediate","process","nextTick","connectionOptions","instanceId","debug","logFile","ignoreTLS","tls","authMethod","name","secureConnection","greetingTimeout","socketTimeout","connectionTimeout","rejectUnathorized","localAddress","connect","_messagesProcessed","on","_onConnectionIdle","bind","_onConnectionMessage","_onConnectionReady","_onConnectionError","_onConnectionEnd","_onConnectionRCPTFailed","emit","currentMessage","currentConnection","useEnvelope","getEnvelope","shift","i","len","splice","addresses","failedRecipients","streamMessage","pipe","success","error","responseObj","socket","removeAllListeners","destroy","_messageId","messageId","Error","data","removed"],"mappings":"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","sourcesContent":["'use strict';\n\nvar simplesmtp = require('../index'),\n    EventEmitter = require('events').EventEmitter,\n    utillib = require('util'),\n    xoauth2 = require('xoauth2');\n\n// expose to the world\nmodule.exports = function(port, host, options) {\n    var pool = new SMTPConnectionPool(port, host, options);\n    return pool;\n};\n\n/**\n * <p>Creates a SMTP connection pool</p>\n *\n * <p>Optional options object takes the following possible properties:</p>\n * <ul>\n *     <li><b>secureConnection</b> - use SSL</li>\n *     <li><b>name</b> - the name of the client server</li>\n *     <li><b>auth</b> - authentication object <code>{user:'...', pass:'...'}</code>\n *     <li><b>ignoreTLS</b> - ignore server support for STARTTLS</li>\n *     <li><b>tls</b> - options for createCredentials</li>\n *     <li><b>debug</b> - output client and server messages to console</li>\n *     <li><b>maxConnections</b> - how many connections to keep in the pool</li>\n * </ul>\n *\n * @constructor\n * @namespace SMTP Client Pool module\n * @param {Number} [port=25] The port number to connecto to\n * @param {String} [host='localhost'] THe hostname to connect to\n * @param {Object} [options] optional options object\n */\nfunction SMTPConnectionPool(port, host, options) {\n    EventEmitter.call(this);\n\n    /**\n     * Port number to connect to\n     * @public\n     */\n    this.port = port || 25;\n\n    /**\n     * Hostname to connect to\n     * @public\n     */\n    this.host = host || 'localhost';\n\n    /**\n     * Options object\n     * @public\n     */\n    this.options = options || {};\n    this.options.maxConnections = this.options.maxConnections || 5;\n    this.options.maxMessages = this.options.maxMessages || Infinity;\n\n    /**\n     * An array of connections that are currently idle\n     * @private\n     */\n    this._connectionsAvailable = [];\n\n    /**\n     * An array of connections that are currently in use\n     * @private\n     */\n    this._connectionsInUse = [];\n\n    /**\n     * Message queue (FIFO)\n     * @private\n     */\n    this._messageQueue = [];\n\n    /**\n     * Counter for generating ID values for debugging\n     * @private\n     */\n    this._idgen = 0;\n\n    // Initialize XOAUTH2 if needed\n    if (this.options.auth && typeof this.options.auth.XOAuth2 == 'object') {\n        if (!this.options.auth.XOAuth2.user && this.options.auth.user) {\n            this.options.auth.XOAuth2.user = this.options.auth.user;\n        }\n        this.options.auth.XOAuth2 = xoauth2.createXOAuth2Generator(this.options.auth.XOAuth2);\n    }\n}\nutillib.inherits(SMTPConnectionPool, EventEmitter);\n\n/**\n * <p>Sends a message. If there's any idling connections available\n * use one to send the message immediatelly, otherwise add to queue.</p>\n *\n * @param {Object} message MailComposer object\n * @param {Function} callback Callback function to run on finish, gets an\n *        <code>error</code> object as a parameter if the sending failed\n *        and on success an object with <code>failedRecipients</code> array as\n *        a list of addresses that were rejected (if any) and\n *        <code>message</code> which indicates the last message received from\n *        the server\n */\nSMTPConnectionPool.prototype.sendMail = function(message, callback) {\n    var connection;\n\n    message.returnCallback = callback;\n\n    if (this._connectionsAvailable.length) {\n        // if available connections pick one\n        connection = this._connectionsAvailable.pop();\n        this._connectionsInUse.push(connection);\n        this._processMessage(message, connection);\n    } else {\n        this._messageQueue.push(message);\n        if (this._connectionsAvailable.length + this._connectionsInUse.length < this.options.maxConnections) {\n            this._createConnection();\n        }\n    }\n};\n\n/**\n * <p>Closes all connections</p>\n */\nSMTPConnectionPool.prototype.close = function(callback) {\n    var connection;\n\n    // for some reason destroying the connections seem to be the only way :S\n    while (this._connectionsAvailable.length) {\n        connection = this._connectionsAvailable.pop();\n        connection.quit();\n    }\n\n    while (this._connectionsInUse.length) {\n        connection = this._connectionsInUse.pop();\n        connection.quit();\n    }\n\n    if (callback) {\n        if (typeof setImmediate == 'function') {\n            setImmediate(callback);\n        } else {\n            process.nextTick(callback);\n        }\n    }\n};\n\n/**\n * <p>Initiates a connection to the SMTP server and adds it to the pool</p>\n */\nSMTPConnectionPool.prototype._createConnection = function() {\n\n    var connectionOptions = {\n        instanceId: ++this._idgen,\n        debug: !! this.options.debug,\n        logFile: this.options.logFile,\n        ignoreTLS: !! this.options.ignoreTLS,\n        tls: this.options.tls || false,\n        auth: this.options.auth || false,\n        authMethod: this.options.authMethod,\n        name: this.options.name || false,\n        secureConnection: !! this.options.secureConnection\n    },\n        connection;\n\n    if ('greetingTimeout' in this.options) {\n        connectionOptions.greetingTimeout = this.options.greetingTimeout;\n    }\n\n    if ('socketTimeout' in this.options) {\n        connectionOptions.socketTimeout = this.options.socketTimeout;\n    }\n\n    if ('connectionTimeout' in this.options) {\n        connectionOptions.connectionTimeout = this.options.connectionTimeout;\n    }\n\n    if ('rejectUnathorized' in this.options) {\n        connectionOptions.rejectUnathorized = this.options.rejectUnathorized;\n    }\n\n    if ('localAddress' in this.options) {\n        connectionOptions.localAddress = this.options.localAddress;\n    }\n\n    connection = simplesmtp.connect(this.port, this.host, connectionOptions);\n\n    connection._messagesProcessed = 0;\n\n    connection.on('idle', this._onConnectionIdle.bind(this, connection));\n    connection.on('message', this._onConnectionMessage.bind(this, connection));\n    connection.on('ready', this._onConnectionReady.bind(this, connection));\n    connection.on('error', this._onConnectionError.bind(this, connection));\n    connection.on('end', this._onConnectionEnd.bind(this, connection));\n    connection.on('rcptFailed', this._onConnectionRCPTFailed.bind(this, connection));\n\n    this.emit('connectionCreated', connection);\n\n    // as the connection is not ready yet, add to 'in use' queue\n    this._connectionsInUse.push(connection);\n};\n\n/**\n * <p>Processes a message by assigning it to a connection object and initiating\n * the sending process by setting the envelope</p>\n *\n * @param {Object} message MailComposer message object\n * @param {Object} connection <code>simplesmtp.connect</code> connection\n */\nSMTPConnectionPool.prototype._processMessage = function(message, connection) {\n    connection.currentMessage = message;\n    message.currentConnection = connection;\n\n    connection._messagesProcessed++;\n\n    // send envelope\n    connection.useEnvelope(message.getEnvelope());\n};\n\n/**\n * <p>Will be fired on <code>'idle'</code> events by the connection, if\n * there's a message currently in queue</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\nSMTPConnectionPool.prototype._onConnectionIdle = function(connection) {\n    var message = this._messageQueue.shift();\n\n    if (message) {\n        this._processMessage(message, connection);\n    } else {\n        for (var i = 0, len = this._connectionsInUse.length; i < len; i++) {\n            if (this._connectionsInUse[i] == connection) {\n                this._connectionsInUse.splice(i, 1); // remove from list\n                break;\n            }\n        }\n        this._connectionsAvailable.push(connection);\n    }\n};\n\n/**\n * <p>Will be called when not all recipients were accepted</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Array} addresses Failed addresses as an array of strings\n */\nSMTPConnectionPool.prototype._onConnectionRCPTFailed = function(connection, addresses) {\n    if (connection.currentMessage) {\n        connection.currentMessage.failedRecipients = addresses;\n    }\n};\n\n/**\n * <p>Will be called when the client is waiting for a message to deliver</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\nSMTPConnectionPool.prototype._onConnectionMessage = function(connection) {\n    if (connection.currentMessage) {\n        connection.currentMessage.streamMessage();\n        connection.currentMessage.pipe(connection);\n    }\n};\n\n/**\n * <p>Will be called when a message has been delivered</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Boolean} success True if the message was queued by the SMTP server\n * @param {String} message Last message received from the server\n */\nSMTPConnectionPool.prototype._onConnectionReady = function(connection, success, message) {\n    var error, responseObj = {};\n\n    if (connection._messagesProcessed >= this.options.maxMessages && connection.socket) {\n\n        connection.emit('end');\n        connection.removeAllListeners();\n        if (connection.socket) {\n            connection.socket.destroy();\n        }\n\n        this.emit('released', connection);\n    }\n\n    if (connection.currentMessage && connection.currentMessage.returnCallback) {\n        if (success) {\n\n            if (connection.currentMessage.failedRecipients) {\n                responseObj.failedRecipients = connection.currentMessage.failedRecipients;\n            }\n\n            if (message) {\n                responseObj.message = message;\n            }\n\n            if (connection.currentMessage._messageId) {\n                responseObj.messageId = connection.currentMessage._messageId;\n            }\n\n            connection.currentMessage.returnCallback(null, responseObj);\n\n        } else {\n            error = new Error('Message delivery failed' + (message ? ': ' + message : ''));\n            error.name = 'DeliveryError';\n            error.data = message;\n            connection.currentMessage.returnCallback(error);\n        }\n    }\n    connection.currentMessage = false;\n};\n\n/**\n * <p>Will be called when an error occurs</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n * @param {Object} error Error object\n */\nSMTPConnectionPool.prototype._onConnectionError = function(connection, error) {\n    var message = connection.currentMessage;\n    connection.currentMessage = false;\n\n    // clear a first message from the list, otherwise an infinite loop will emerge\n    if (!message) {\n        message = this._messageQueue.shift();\n    }\n\n    if (message && message.returnCallback) {\n        message.returnCallback(error);\n    }\n};\n\n/**\n * <p>Will be called when a connection to the client is closed</p>\n *\n * @event\n * @param {Object} connection Connection object that fired the event\n */\nSMTPConnectionPool.prototype._onConnectionEnd = function(connection) {\n    var removed = false,\n        i, len;\n\n    // if in 'available' list, remove\n    for (i = 0, len = this._connectionsAvailable.length; i < len; i++) {\n        if (this._connectionsAvailable[i] == connection) {\n            this._connectionsAvailable.splice(i, 1); // remove from list\n            removed = true;\n            break;\n        }\n    }\n\n    if (!removed) {\n        // if in 'in use' list, remove\n        for (i = 0, len = this._connectionsInUse.length; i < len; i++) {\n            if (this._connectionsInUse[i] == connection) {\n                this._connectionsInUse.splice(i, 1); // remove from list\n                removed = true;\n                break;\n            }\n        }\n    }\n\n    // if there's still unprocessed mail and available connection slots, create\n    // a new connection\n    if (this._messageQueue.length &&\n        this._connectionsInUse.length + this._connectionsAvailable.length < this.options.maxConnections) {\n        this._createConnection();\n    }\n};"]},"metadata":{},"sourceType":"script"}
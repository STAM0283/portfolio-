{"ast":null,"code":"// wrapper for non-node envs\n;\n\n(function (sax) {\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  var buffers = [\"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\", \"procInstName\", \"procInstBody\", \"entity\", \"attribName\", \"attribValue\", \"cdata\", \"script\"];\n  sax.EVENTS = // for discoverability.\n  [\"text\", \"processinginstruction\", \"sgmldeclaration\", \"doctype\", \"comment\", \"attribute\", \"opentag\", \"closetag\", \"opencdata\", \"cdata\", \"closecdata\", \"error\", \"end\", \"ready\", \"script\", \"opennamespace\", \"closenamespace\"];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.ENTITIES = Object.create(sax.ENTITIES);\n    parser.attribList = []; // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n\n    if (parser.opt.xmlns) parser.ns = Object.create(rootNS); // mostly just for error reporting\n\n    parser.trackPosition = parser.opt.position !== false;\n\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) Object.create = function (o) {\n    function f() {\n      this.__proto__ = o;\n    }\n\n    f.prototype = o;\n    return new f();\n  };\n  if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n    return o.__proto__;\n  };\n  if (!Object.keys) Object.keys = function (o) {\n    var a = [];\n\n    for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n\n    return a;\n  };\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10),\n        maxActual = 0;\n\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n\n      maxActual = Math.max(maxActual, len);\n    } // schedule the next check for the earliest possible buffer overrun.\n\n\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH - maxActual + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    }\n  };\n\n  try {\n    var Stream = require(\"stream\").Stream;\n  } catch (ex) {\n    var Stream = function () {};\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);\n    Stream.apply(me);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er); // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            return me._parser[\"on\" + ev] = h;\n          }\n\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n\n    this._parser.end();\n\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  }; // character classes and tokens\n\n\n  var whitespace = \"\\r\\n\\t \" // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  ,\n      number = \"0124356789\",\n      letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" // (Letter | \"_\" | \":\")\n  ,\n      nameStart = letter + \"_:\",\n      nameBody = nameStart + number + \"-.\",\n      quote = \"'\\\"\",\n      entity = number + letter + \"#\",\n      attribEnd = whitespace + \">\",\n      CDATA = \"[CDATA[\",\n      DOCTYPE = \"DOCTYPE\",\n      XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\",\n      XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\",\n      rootNS = {\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE\n  }; // turn all the string character sets into character class objects.\n\n  whitespace = charClass(whitespace);\n  number = charClass(number);\n  letter = charClass(letter);\n  nameStart = charClass(nameStart);\n  nameBody = charClass(nameBody);\n  quote = charClass(quote);\n  entity = charClass(entity);\n  attribEnd = charClass(attribEnd);\n\n  function charClass(str) {\n    return str.split(\"\").reduce(function (s, c) {\n      s[c] = true;\n      return s;\n    }, {});\n  }\n\n  function is(charclass, c) {\n    return charclass[c];\n  }\n\n  function not(charclass, c) {\n    return !charclass[c];\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    TEXT: S++ // general stuff\n    ,\n    TEXT_ENTITY: S++ // &amp and such.\n    ,\n    OPEN_WAKA: S++ // <\n    ,\n    SGML_DECL: S++ // <!BLARG\n    ,\n    SGML_DECL_QUOTED: S++ // <!BLARG foo \"bar\n    ,\n    DOCTYPE: S++ // <!DOCTYPE\n    ,\n    DOCTYPE_QUOTED: S++ // <!DOCTYPE \"//blah\n    ,\n    DOCTYPE_DTD: S++ // <!DOCTYPE \"//blah\" [ ...\n    ,\n    DOCTYPE_DTD_QUOTED: S++ // <!DOCTYPE \"//blah\" [ \"foo\n    ,\n    COMMENT_STARTING: S++ // <!-\n    ,\n    COMMENT: S++ // <!--\n    ,\n    COMMENT_ENDING: S++ // <!-- blah -\n    ,\n    COMMENT_ENDED: S++ // <!-- blah --\n    ,\n    CDATA: S++ // <![CDATA[ something\n    ,\n    CDATA_ENDING: S++ // ]\n    ,\n    CDATA_ENDING_2: S++ // ]]\n    ,\n    PROC_INST: S++ // <?hi\n    ,\n    PROC_INST_BODY: S++ // <?hi there\n    ,\n    PROC_INST_QUOTED: S++ // <?hi \"there\n    ,\n    PROC_INST_ENDING: S++ // <?hi \"there\" ?\n    ,\n    OPEN_TAG: S++ // <strong\n    ,\n    OPEN_TAG_SLASH: S++ // <strong /\n    ,\n    ATTRIB: S++ // <a\n    ,\n    ATTRIB_NAME: S++ // <a foo\n    ,\n    ATTRIB_NAME_SAW_WHITE: S++ // <a foo _\n    ,\n    ATTRIB_VALUE: S++ // <a foo=\n    ,\n    ATTRIB_VALUE_QUOTED: S++ // <a foo=\"bar\n    ,\n    ATTRIB_VALUE_UNQUOTED: S++ // <a foo=bar\n    ,\n    ATTRIB_VALUE_ENTITY_Q: S++ // <foo bar=\"&quot;\"\n    ,\n    ATTRIB_VALUE_ENTITY_U: S++ // <foo bar=&quot;\n    ,\n    CLOSE_TAG: S++ // </a\n    ,\n    CLOSE_TAG_SAW_WHITE: S++ // </a   >\n    ,\n    SCRIPT: S++ // <script> ...\n    ,\n    SCRIPT_ENDING: S++ // <script> ... <\n\n  };\n  sax.ENTITIES = {\n    \"apos\": \"'\",\n    \"quot\": \"\\\"\",\n    \"amp\": \"&\",\n    \"gt\": \">\",\n    \"lt\": \"<\"\n  };\n\n  for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S; // shorthand\n\n\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n\n    if (parser.trackPosition) {\n      er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.TEXT) error(parser, \"Unexpected end\");\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (parser.strict) error(parser, message);\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser,\n        tag = parser.tag = {\n      name: parser.tagName,\n      attributes: {}\n    }; // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\n    if (parser.opt.xmlns) tag.ns = parent.ns;\n    parser.attribList.length = 0;\n  }\n\n  function qname(name) {\n    var i = name.indexOf(\":\"),\n        qualName = i < 0 ? [\"\", name] : name.split(\":\"),\n        prefix = qualName[0],\n        local = qualName[1]; // <x \"xmlns\"=\"http://foo\">\n\n    if (name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName),\n          prefix = qn.prefix,\n          local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute; push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else {\n          var tag = parser.tag,\n              parent = parser.tags[parser.tags.length - 1] || parser;\n\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n\n          tag.ns[local] = parser.attribValue;\n        }\n      } // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect; preserve attribute order\n      // so deferred events can be emitted in document order\n\n\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag; // add namespace info to tag\n\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || qn.prefix;\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      } // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0],\n            value = nv[1],\n            qualName = qname(name),\n            prefix = qualName.prefix,\n            local = qualName.local,\n            uri = prefix == \"\" ? \"\" : tag.ns[prefix] || \"\",\n            a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }; // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (prefix && prefix != \"xmlns\" && !uri) {\n          strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n\n      parser.attribList.length = 0;\n    } // process the tag\n\n\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    } // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n\n\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) tagName = tagName[parser.looseCase]();\n    var closeTo = tagName;\n\n    while (t--) {\n      var close = parser.tags[t];\n\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else break;\n    } // didn't find it.  we already failed for strict, so just abort.\n\n\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n      var x = {};\n\n      for (var i in tag.ns) x[i] = tag.ns[i];\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity.toLowerCase(),\n        num,\n        numStr = \"\";\n    if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];\n\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n\n    entity = entity.replace(/^0+/, \"\");\n\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCharCode(num);\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0,\n        c = \"\";\n\n    while (parser.c = c = chunk.charAt(i++)) {\n      if (parser.trackPosition) {\n        parser.position++;\n\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else parser.column++;\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          if (c === \"<\") parser.state = S.OPEN_WAKA;else if (not(whitespace, c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = chunk.charAt(i++);\n\n              if (c && parser.trackPosition) {\n                parser.position++;\n\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else parser.column++;\n              }\n            }\n\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n\n          if (c === \"<\") parser.state = S.OPEN_WAKA;else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) strictFail(\"Text data outside of root node.\");\n            if (c === \"&\") parser.state = S.TEXT_ENTITY;else parser.textNode += c;\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else parser.script += c;\n\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.state = S.CLOSE_TAG;\n            parser.script = \"\";\n            parser.tagName = \"\";\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (is(whitespace, c)) {// wait for it...\n          } else if (is(nameStart, c)) {\n            parser.startTagPosition = parser.position - 1;\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.startTagPosition = parser.position - 1;\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) strictFail(parser, \"Inappropriately located doctype declaration\");\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else parser.sgmlDecl += c;\n\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") parser.state = S.DOCTYPE_DTD;else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") parser.state = S.DOCTYPE;else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") parser.state = S.COMMENT_ENDING;else parser.comment += c;\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) emitNode(parser, \"oncomment\", parser.comment);\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\"); // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else parser.state = S.TEXT;\n\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") parser.state = S.CDATA_ENDING;else parser.cdata += c;\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") parser.state = S.CDATA_ENDING_2;else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata);\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY;else parser.procInstName += c;\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) continue;else if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(quote, c)) {\n            parser.state = S.PROC_INST_QUOTED;\n            parser.q = c;\n            parser.procInstBody += c;\n          } else parser.procInstBody += c;\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n\n          continue;\n\n        case S.PROC_INST_QUOTED:\n          parser.procInstBody += c;\n\n          if (c === parser.q) {\n            parser.state = S.PROC_INST_BODY;\n            parser.q = \"\";\n          }\n\n          continue;\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) parser.tagName += c;else {\n            newTag(parser);\n            if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else {\n              if (not(whitespace, c)) strictFail(parser, \"Invalid character in tag name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n            parser.state = S.ATTRIB;\n          }\n\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) continue;else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;else if (is(nameBody, c)) parser.attribName += c;else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) continue;else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\"\n            });\n            parser.attribName = \"\";\n            if (c === \">\") openTag(parser);else if (is(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) continue;else if (is(quote, c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB;\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          if (c === \">\") openTag(parser);else parser.state = S.ATTRIB;\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) continue;else if (not(nameStart, c)) strictFail(parser, \"Invalid tagname in closing tag.\");else parser.tagName = c;\n          } else if (c === \">\") closeTag(parser);else if (is(nameBody, c)) parser.tagName += c;else {\n            if (not(whitespace, c)) strictFail(parser, \"Invalid tagname in closing tag\");\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) continue;\n          if (c === \">\") closeTag(parser);else strictFail(\"Invalid characters in closing tag\");\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              var returnState = S.TEXT,\n                  buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              var returnState = S.ATTRIB_VALUE_QUOTED,\n                  buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState = S.ATTRIB_VALUE_UNQUOTED,\n                  buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            parser[buffer] += parseEntity(parser);\n            parser.entity = \"\";\n            parser.state = returnState;\n          } else if (is(entity, c)) parser.entity += c;else {\n            strictFail(\"Invalid character entity\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default:\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n      }\n    } // while\n    // cdata blocks can get very big under normal conditions. emit and move on.\n    // if (parser.state === S.CDATA && parser.cdata) {\n    //   emitNode(parser, \"oncdata\", parser.cdata)\n    //   parser.cdata = \"\"\n    // }\n\n\n    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);\n    return parser;\n  }\n})(typeof exports === \"undefined\" ? sax = {} : exports);","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/xml2js/node_modules/sax/lib/sax.js"],"names":["sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","buffers","EVENTS","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","ENTITIES","Object","create","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","emit","o","f","__proto__","prototype","getPrototypeOf","keys","a","i","hasOwnProperty","push","checkBufferLength","maxAllowed","Math","max","maxActual","l","length","len","closeText","emitNode","cdata","script","end","write","resume","close","Stream","require","ex","streamWraps","filter","ev","apply","me","_parser","writable","readable","onend","onerror","er","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","value","data","toString","chunk","handler","indexOf","args","arguments","Array","splice","call","whitespace","number","letter","nameStart","nameBody","quote","entity","attribEnd","CDATA","DOCTYPE","XML_NAMESPACE","XMLNS_NAMESPACE","xml","charClass","str","split","reduce","s","is","charclass","not","STATE","TEXT","TEXT_ENTITY","OPEN_WAKA","SGML_DECL","SGML_DECL_QUOTED","DOCTYPE_QUOTED","DOCTYPE_DTD","DOCTYPE_DTD_QUOTED","COMMENT_STARTING","COMMENT","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST","PROC_INST_BODY","PROC_INST_QUOTED","PROC_INST_ENDING","OPEN_TAG","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG","CLOSE_TAG_SAW_WHITE","SCRIPT","SCRIPT_ENDING","event","nodeType","textNode","textopts","text","trim","normalize","replace","Error","strictFail","message","newTag","tagName","parent","name","attributes","qname","qualName","prefix","local","attrib","attribName","qn","attribValue","openTag","selfClosing","uri","JSON","stringify","p","nv","toLowerCase","closeTag","t","closeTo","pop","x","n","parseEntity","num","numStr","charAt","slice","parseInt","String","fromCharCode","starti","substring","sgmlDecl","startTagPosition","procInstName","procInstBody","toUpperCase","comment","doctype","body","returnState","buffer","exports"],"mappings":"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","sourcesContent":["// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n  parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.trackPosition = parser.opt.position !== false\n  if (parser.trackPosition) {\n    parser.position = parser.line = parser.column = 0\n  }\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(me)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this._parser.write(chunk.toString())\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"\\r\\n\\t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , nameStart = letter+\"_:\"\n  , nameBody = nameStart+number+\"-.\"\n  , quote = \"'\\\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\nnameStart = charClass(nameStart)\nnameBody = charClass(nameBody)\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction is (charclass, c) {\n  return charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !charclass[c]\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_QUOTED          : S++ // <?hi \"there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"apos\" : \"'\"\n, \"quot\" : \"\\\"\"\n, \"amp\"  : \"&\"\n, \"gt\"   : \">\"\n, \"lt\"   : \"<\"\n}\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(/\\s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  if (parser.trackPosition) {\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c\n  }\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (parser.state !== S.TEXT) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || qn.prefix\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = prefix == \"\" ? \"\" : (tag.ns[prefix] || \"\")\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.looseCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity]) return parser.ENTITIES[entity]\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n  return String.fromCharCode(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    if (parser.trackPosition) {\n      parser.position ++\n      if (c === \"\\n\") {\n        parser.line ++\n        parser.column = 0\n      } else parser.column ++\n    }\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") parser.state = S.OPEN_WAKA\n        else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c && parser.trackPosition) {\n              parser.position ++\n              if (c === \"\\n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") parser.state = S.OPEN_WAKA\n        else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(\"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          emitNode(parser, \"onscript\", parser.script)\n          parser.state = S.CLOSE_TAG\n          parser.script = \"\"\n          parser.tagName = \"\"\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.startTagPosition = parser.position - 1\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.startTagPosition = parser.position - 1\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(quote, c)) {\n          parser.state = S.PROC_INST_QUOTED\n          parser.q = c\n          parser.procInstBody += c\n        } else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.PROC_INST_QUOTED:\n        parser.procInstBody += c\n        if (c === parser.q) {\n          parser.state = S.PROC_INST_BODY\n          parser.q = \"\"\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) strictFail(parser,\n            \"Invalid tagname in closing tag.\")\n          else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(\"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(\"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports)\n"]},"metadata":{},"sourceType":"script"}
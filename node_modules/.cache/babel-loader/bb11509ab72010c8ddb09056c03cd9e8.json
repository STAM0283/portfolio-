{"ast":null,"code":"var fs = require('fs'),\n    path = require('path');\n/**\n * Loads templates from the file system.\n * @alias swig.loaders.fs\n * @example\n * swig.setDefaults({ loader: swig.loaders.fs() });\n * @example\n * // Load Templates from a specific directory (does not require using relative paths in your templates)\n * swig.setDefaults({ loader: swig.loaders.fs(__dirname + '/templates' )});\n * @param {string}   [basepath='']     Path to the templates as string. Assigning this value allows you to use semi-absolute paths to templates instead of relative paths.\n * @param {string}   [encoding='utf8']   Template encoding\n */\n\n\nmodule.exports = function (basepath, encoding) {\n  var ret = {};\n  encoding = encoding || 'utf8';\n  basepath = basepath ? path.normalize(basepath) : null;\n  /**\n   * Resolves <var>to</var> to an absolute path or unique identifier. This is used for building correct, normalized, and absolute paths to a given template.\n   * @alias resolve\n   * @param  {string} to        Non-absolute identifier or pathname to a file.\n   * @param  {string} [from]    If given, should attempt to find the <var>to</var> path in relation to this given, known path.\n   * @return {string}\n   */\n\n  ret.resolve = function (to, from) {\n    if (basepath) {\n      from = basepath;\n    } else {\n      from = from ? path.dirname(from) : process.cwd();\n    }\n\n    return path.resolve(from, to);\n  };\n  /**\n   * Loads a single template. Given a unique <var>identifier</var> found by the <var>resolve</var> method this should return the given template.\n   * @alias load\n   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).\n   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.\n   * @return {string}               Template source string.\n   */\n\n\n  ret.load = function (identifier, cb) {\n    if (!fs || cb && !fs.readFile || !fs.readFileSync) {\n      throw new Error('Unable to find file ' + identifier + ' because there is no filesystem to read from.');\n    }\n\n    identifier = ret.resolve(identifier);\n\n    if (cb) {\n      fs.readFile(identifier, encoding, cb);\n      return;\n    }\n\n    return fs.readFileSync(identifier, encoding);\n  };\n\n  return ret;\n};","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/swig/lib/loaders/filesystem.js"],"names":["fs","require","path","module","exports","basepath","encoding","ret","normalize","resolve","to","from","dirname","process","cwd","load","identifier","cb","readFile","readFileSync","Error"],"mappings":"AAAA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;AAAA,IACEC,IAAI,GAAGD,OAAO,CAAC,MAAD,CADhB;AAGA;;;;;;;;;;;;;AAWAE,MAAM,CAACC,OAAP,GAAiB,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;AAC7C,MAAIC,GAAG,GAAG,EAAV;AAEAD,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,MAAvB;AACAD,EAAAA,QAAQ,GAAIA,QAAD,GAAaH,IAAI,CAACM,SAAL,CAAeH,QAAf,CAAb,GAAwC,IAAnD;AAEA;;;;;;;;AAOAE,EAAAA,GAAG,CAACE,OAAJ,GAAc,UAAUC,EAAV,EAAcC,IAAd,EAAoB;AAChC,QAAIN,QAAJ,EAAc;AACZM,MAAAA,IAAI,GAAGN,QAAP;AACD,KAFD,MAEO;AACLM,MAAAA,IAAI,GAAIA,IAAD,GAAST,IAAI,CAACU,OAAL,CAAaD,IAAb,CAAT,GAA8BE,OAAO,CAACC,GAAR,EAArC;AACD;;AACD,WAAOZ,IAAI,CAACO,OAAL,CAAaE,IAAb,EAAmBD,EAAnB,CAAP;AACD,GAPD;AASA;;;;;;;;;AAOAH,EAAAA,GAAG,CAACQ,IAAJ,GAAW,UAAUC,UAAV,EAAsBC,EAAtB,EAA0B;AACnC,QAAI,CAACjB,EAAD,IAAQiB,EAAE,IAAI,CAACjB,EAAE,CAACkB,QAAlB,IAA+B,CAAClB,EAAE,CAACmB,YAAvC,EAAqD;AACnD,YAAM,IAAIC,KAAJ,CAAU,yBAAyBJ,UAAzB,GAAsC,+CAAhD,CAAN;AACD;;AAEDA,IAAAA,UAAU,GAAGT,GAAG,CAACE,OAAJ,CAAYO,UAAZ,CAAb;;AAEA,QAAIC,EAAJ,EAAQ;AACNjB,MAAAA,EAAE,CAACkB,QAAH,CAAYF,UAAZ,EAAwBV,QAAxB,EAAkCW,EAAlC;AACA;AACD;;AACD,WAAOjB,EAAE,CAACmB,YAAH,CAAgBH,UAAhB,EAA4BV,QAA5B,CAAP;AACD,GAZD;;AAcA,SAAOC,GAAP;AACD,CA5CD","sourcesContent":["var fs = require('fs'),\n  path = require('path');\n\n/**\n * Loads templates from the file system.\n * @alias swig.loaders.fs\n * @example\n * swig.setDefaults({ loader: swig.loaders.fs() });\n * @example\n * // Load Templates from a specific directory (does not require using relative paths in your templates)\n * swig.setDefaults({ loader: swig.loaders.fs(__dirname + '/templates' )});\n * @param {string}   [basepath='']     Path to the templates as string. Assigning this value allows you to use semi-absolute paths to templates instead of relative paths.\n * @param {string}   [encoding='utf8']   Template encoding\n */\nmodule.exports = function (basepath, encoding) {\n  var ret = {};\n\n  encoding = encoding || 'utf8';\n  basepath = (basepath) ? path.normalize(basepath) : null;\n\n  /**\n   * Resolves <var>to</var> to an absolute path or unique identifier. This is used for building correct, normalized, and absolute paths to a given template.\n   * @alias resolve\n   * @param  {string} to        Non-absolute identifier or pathname to a file.\n   * @param  {string} [from]    If given, should attempt to find the <var>to</var> path in relation to this given, known path.\n   * @return {string}\n   */\n  ret.resolve = function (to, from) {\n    if (basepath) {\n      from = basepath;\n    } else {\n      from = (from) ? path.dirname(from) : process.cwd();\n    }\n    return path.resolve(from, to);\n  };\n\n  /**\n   * Loads a single template. Given a unique <var>identifier</var> found by the <var>resolve</var> method this should return the given template.\n   * @alias load\n   * @param  {string}   identifier  Unique identifier of a template (possibly an absolute path).\n   * @param  {function} [cb]        Asynchronous callback function. If not provided, this method should run synchronously.\n   * @return {string}               Template source string.\n   */\n  ret.load = function (identifier, cb) {\n    if (!fs || (cb && !fs.readFile) || !fs.readFileSync) {\n      throw new Error('Unable to find file ' + identifier + ' because there is no filesystem to read from.');\n    }\n\n    identifier = ret.resolve(identifier);\n\n    if (cb) {\n      fs.readFile(identifier, encoding, cb);\n      return;\n    }\n    return fs.readFileSync(identifier, encoding);\n  };\n\n  return ret;\n};\n"]},"metadata":{},"sourceType":"script"}
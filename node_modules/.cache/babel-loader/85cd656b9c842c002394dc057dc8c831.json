{"ast":null,"code":"var utils = require('../utils');\n/**\n * Allows you to import macros from another file directly into your current context.\n * The import tag is specifically designed for importing macros into your template with a specific context scope. This is very useful for keeping your macros from overriding template context that is being injected by your server-side page generation.\n *\n * @alias import\n *\n * @example\n * {% import './formmacros.html' as forms %}\n * {{ form.input(\"text\", \"name\") }}\n * // => <input type=\"text\" name=\"name\">\n *\n * @example\n * {% import \"../shared/tags.html\" as tags %}\n * {{ tags.stylesheet('global') }}\n * // => <link rel=\"stylesheet\" href=\"/global.css\">\n *\n * @param {string|var}  file      Relative path from the current template file to the file to import macros from.\n * @param {literal}     as        Literally, \"as\".\n * @param {literal}     varname   Local-accessible object name to assign the macros to.\n */\n\n\nexports.compile = function (compiler, args) {\n  var ctx = args.pop(),\n      out = '_ctx.' + ctx + ' = {};\\n  var _output = \"\";\\n',\n      replacements = utils.map(args, function (arg) {\n    return {\n      ex: new RegExp('_ctx.' + arg.name, 'g'),\n      re: '_ctx.' + ctx + '.' + arg.name\n    };\n  }); // Replace all occurrences of all macros in this file with\n  // proper namespaced definitions and calls\n\n  utils.each(args, function (arg) {\n    var c = arg.compiled;\n    utils.each(replacements, function (re) {\n      c = c.replace(re.ex, re.re);\n    });\n    out += c;\n  });\n  return out;\n};\n\nexports.parse = function (str, line, parser, types, stack, opts, swig) {\n  var compiler = require('../parser').compile,\n      parseOpts = {\n    resolveFrom: opts.filename\n  },\n      compileOpts = utils.extend({}, opts, parseOpts),\n      tokens,\n      ctx;\n\n  parser.on(types.STRING, function (token) {\n    var self = this;\n\n    if (!tokens) {\n      tokens = swig.parseFile(token.match.replace(/^(\"|')|(\"|')$/g, ''), parseOpts).tokens;\n      utils.each(tokens, function (token) {\n        var out = '',\n            macroName;\n\n        if (!token || token.name !== 'macro' || !token.compile) {\n          return;\n        }\n\n        macroName = token.args[0];\n        out += token.compile(compiler, token.args, token.content, [], compileOpts) + '\\n';\n        self.out.push({\n          compiled: out,\n          name: macroName\n        });\n      });\n      return;\n    }\n\n    throw new Error('Unexpected string ' + token.match + ' on line ' + line + '.');\n  });\n  parser.on(types.VAR, function (token) {\n    var self = this;\n\n    if (!tokens || ctx) {\n      throw new Error('Unexpected variable \"' + token.match + '\" on line ' + line + '.');\n    }\n\n    if (token.match === 'as') {\n      return;\n    }\n\n    ctx = token.match;\n    self.out.push(ctx);\n    return false;\n  });\n  return true;\n};\n\nexports.block = true;","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/swig/lib/tags/import.js"],"names":["utils","require","exports","compile","compiler","args","ctx","pop","out","replacements","map","arg","ex","RegExp","name","re","each","c","compiled","replace","parse","str","line","parser","types","stack","opts","swig","parseOpts","resolveFrom","filename","compileOpts","extend","tokens","on","STRING","token","self","parseFile","match","macroName","content","push","Error","VAR","block"],"mappings":"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","sourcesContent":["var utils = require('../utils');\n\n/**\n * Allows you to import macros from another file directly into your current context.\n * The import tag is specifically designed for importing macros into your template with a specific context scope. This is very useful for keeping your macros from overriding template context that is being injected by your server-side page generation.\n *\n * @alias import\n *\n * @example\n * {% import './formmacros.html' as forms %}\n * {{ form.input(\"text\", \"name\") }}\n * // => <input type=\"text\" name=\"name\">\n *\n * @example\n * {% import \"../shared/tags.html\" as tags %}\n * {{ tags.stylesheet('global') }}\n * // => <link rel=\"stylesheet\" href=\"/global.css\">\n *\n * @param {string|var}  file      Relative path from the current template file to the file to import macros from.\n * @param {literal}     as        Literally, \"as\".\n * @param {literal}     varname   Local-accessible object name to assign the macros to.\n */\nexports.compile = function (compiler, args) {\n  var ctx = args.pop(),\n    out = '_ctx.' + ctx + ' = {};\\n  var _output = \"\";\\n',\n    replacements = utils.map(args, function (arg) {\n      return {\n        ex: new RegExp('_ctx.' + arg.name, 'g'),\n        re: '_ctx.' + ctx + '.' + arg.name\n      };\n    });\n\n  // Replace all occurrences of all macros in this file with\n  // proper namespaced definitions and calls\n  utils.each(args, function (arg) {\n    var c = arg.compiled;\n    utils.each(replacements, function (re) {\n      c = c.replace(re.ex, re.re);\n    });\n    out += c;\n  });\n\n  return out;\n};\n\nexports.parse = function (str, line, parser, types, stack, opts, swig) {\n  var compiler = require('../parser').compile,\n    parseOpts = { resolveFrom: opts.filename },\n    compileOpts = utils.extend({}, opts, parseOpts),\n    tokens,\n    ctx;\n\n  parser.on(types.STRING, function (token) {\n    var self = this;\n    if (!tokens) {\n      tokens = swig.parseFile(token.match.replace(/^(\"|')|(\"|')$/g, ''), parseOpts).tokens;\n      utils.each(tokens, function (token) {\n        var out = '',\n          macroName;\n        if (!token || token.name !== 'macro' || !token.compile) {\n          return;\n        }\n        macroName = token.args[0];\n        out += token.compile(compiler, token.args, token.content, [], compileOpts) + '\\n';\n        self.out.push({compiled: out, name: macroName});\n      });\n      return;\n    }\n\n    throw new Error('Unexpected string ' + token.match + ' on line ' + line + '.');\n  });\n\n  parser.on(types.VAR, function (token) {\n    var self = this;\n    if (!tokens || ctx) {\n      throw new Error('Unexpected variable \"' + token.match + '\" on line ' + line + '.');\n    }\n\n    if (token.match === 'as') {\n      return;\n    }\n\n    ctx = token.match;\n    self.out.push(ctx);\n    return false;\n  });\n\n  return true;\n};\n\nexports.block = true;\n"]},"metadata":{},"sourceType":"script"}
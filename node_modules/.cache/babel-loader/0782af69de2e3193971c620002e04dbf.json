{"ast":null,"code":"var AWS = require('../core');\n\nAWS.util.update(AWS.Glacier.prototype, {\n  /**\n   * @api private\n   */\n  setupRequestListeners: function setupRequestListeners(request) {\n    if (Array.isArray(request._events.validate)) {\n      request._events.validate.unshift(this.validateAccountId);\n    } else {\n      request.on('validate', this.validateAccountId);\n    }\n\n    request.on('build', this.addGlacierApiVersion);\n    request.on('build', this.addTreeHashHeaders);\n  },\n\n  /**\n   * @api private\n   */\n  validateAccountId: function validateAccountId(request) {\n    if (request.params.accountId !== undefined) return;\n    request.params = AWS.util.copy(request.params);\n    request.params.accountId = '-';\n  },\n\n  /**\n   * @api private\n   */\n  addGlacierApiVersion: function addGlacierApiVersion(request) {\n    var version = request.service.api.apiVersion;\n    request.httpRequest.headers['x-amz-glacier-version'] = version;\n  },\n\n  /**\n   * @api private\n   */\n  addTreeHashHeaders: function addTreeHashHeaders(request) {\n    if (request.params.body === undefined) return;\n    var hashes = request.service.computeChecksums(request.params.body);\n    request.httpRequest.headers['x-amz-content-sha256'] = hashes.linearHash;\n\n    if (!request.httpRequest.headers['x-amz-sha256-tree-hash']) {\n      request.httpRequest.headers['x-amz-sha256-tree-hash'] = hashes.treeHash;\n    }\n  },\n\n  /**\n   * @!group Computing Checksums\n   */\n\n  /**\n   * Computes the SHA-256 linear and tree hash checksums for a given\n   * block of Buffer data. Pass the tree hash of the computed checksums\n   * as the checksum input to the {completeMultipartUpload} when performing\n   * a multi-part upload.\n   *\n   * @example Calculate checksum of 5.5MB data chunk\n   *   var glacier = new AWS.Glacier();\n   *   var data = new Buffer(5.5 * 1024 * 1024);\n   *   data.fill('0'); // fill with zeros\n   *   var results = glacier.computeChecksums(data);\n   *   // Result: { linearHash: '68aff0c5a9...', treeHash: '154e26c78f...' }\n   * @param data [Buffer, String] data to calculate the checksum for\n   * @return [map<linearHash:String,treeHash:String>] a map containing\n   *   the linearHash and treeHash properties representing hex based digests\n   *   of the respective checksums.\n   * @see completeMultipartUpload\n   */\n  computeChecksums: function computeChecksums(data) {\n    if (!AWS.util.Buffer.isBuffer(data)) data = new AWS.util.Buffer(data);\n    var mb = 1024 * 1024;\n    var hashes = [];\n    var hash = AWS.util.crypto.createHash('sha256'); // build leaf nodes in 1mb chunks\n\n    for (var i = 0; i < data.length; i += mb) {\n      var chunk = data.slice(i, Math.min(i + mb, data.length));\n      hash.update(chunk);\n      hashes.push(AWS.util.crypto.sha256(chunk));\n    }\n\n    return {\n      linearHash: hash.digest('hex'),\n      treeHash: this.buildHashTree(hashes)\n    };\n  },\n\n  /**\n   * @api private\n   */\n  buildHashTree: function buildHashTree(hashes) {\n    // merge leaf nodes\n    while (hashes.length > 1) {\n      var tmpHashes = [];\n\n      for (var i = 0; i < hashes.length; i += 2) {\n        if (hashes[i + 1]) {\n          var tmpHash = new AWS.util.Buffer(64);\n          tmpHash.write(hashes[i], 0, 32, 'binary');\n          tmpHash.write(hashes[i + 1], 32, 32, 'binary');\n          tmpHashes.push(AWS.util.crypto.sha256(tmpHash));\n        } else {\n          tmpHashes.push(hashes[i]);\n        }\n      }\n\n      hashes = tmpHashes;\n    }\n\n    return AWS.util.crypto.toHex(hashes[0]);\n  }\n});","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/aws-sdk/lib/services/glacier.js"],"names":["AWS","require","util","update","Glacier","prototype","setupRequestListeners","request","Array","isArray","_events","validate","unshift","validateAccountId","on","addGlacierApiVersion","addTreeHashHeaders","params","accountId","undefined","copy","version","service","api","apiVersion","httpRequest","headers","body","hashes","computeChecksums","linearHash","treeHash","data","Buffer","isBuffer","mb","hash","crypto","createHash","i","length","chunk","slice","Math","min","push","sha256","digest","buildHashTree","tmpHashes","tmpHash","write","toHex"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAjB;;AAEAD,GAAG,CAACE,IAAJ,CAASC,MAAT,CAAgBH,GAAG,CAACI,OAAJ,CAAYC,SAA5B,EAAuC;AACrC;;;AAGAC,EAAAA,qBAAqB,EAAE,SAASA,qBAAT,CAA+BC,OAA/B,EAAwC;AAC7D,QAAIC,KAAK,CAACC,OAAN,CAAcF,OAAO,CAACG,OAAR,CAAgBC,QAA9B,CAAJ,EAA6C;AAC3CJ,MAAAA,OAAO,CAACG,OAAR,CAAgBC,QAAhB,CAAyBC,OAAzB,CAAiC,KAAKC,iBAAtC;AACD,KAFD,MAEO;AACLN,MAAAA,OAAO,CAACO,EAAR,CAAW,UAAX,EAAuB,KAAKD,iBAA5B;AACD;;AAEDN,IAAAA,OAAO,CAACO,EAAR,CAAW,OAAX,EAAoB,KAAKC,oBAAzB;AACAR,IAAAA,OAAO,CAACO,EAAR,CAAW,OAAX,EAAoB,KAAKE,kBAAzB;AACD,GAboC;;AAerC;;;AAGAH,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,CAA2BN,OAA3B,EAAoC;AACrD,QAAIA,OAAO,CAACU,MAAR,CAAeC,SAAf,KAA6BC,SAAjC,EAA4C;AAC5CZ,IAAAA,OAAO,CAACU,MAAR,GAAiBjB,GAAG,CAACE,IAAJ,CAASkB,IAAT,CAAcb,OAAO,CAACU,MAAtB,CAAjB;AACAV,IAAAA,OAAO,CAACU,MAAR,CAAeC,SAAf,GAA2B,GAA3B;AACD,GAtBoC;;AAwBrC;;;AAGAH,EAAAA,oBAAoB,EAAE,SAASA,oBAAT,CAA8BR,OAA9B,EAAuC;AAC3D,QAAIc,OAAO,GAAGd,OAAO,CAACe,OAAR,CAAgBC,GAAhB,CAAoBC,UAAlC;AACAjB,IAAAA,OAAO,CAACkB,WAAR,CAAoBC,OAApB,CAA4B,uBAA5B,IAAuDL,OAAvD;AACD,GA9BoC;;AAgCrC;;;AAGAL,EAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BT,OAA5B,EAAqC;AACvD,QAAIA,OAAO,CAACU,MAAR,CAAeU,IAAf,KAAwBR,SAA5B,EAAuC;AAEvC,QAAIS,MAAM,GAAGrB,OAAO,CAACe,OAAR,CAAgBO,gBAAhB,CAAiCtB,OAAO,CAACU,MAAR,CAAeU,IAAhD,CAAb;AACApB,IAAAA,OAAO,CAACkB,WAAR,CAAoBC,OAApB,CAA4B,sBAA5B,IAAsDE,MAAM,CAACE,UAA7D;;AAEA,QAAI,CAACvB,OAAO,CAACkB,WAAR,CAAoBC,OAApB,CAA4B,wBAA5B,CAAL,EAA4D;AAC1DnB,MAAAA,OAAO,CAACkB,WAAR,CAAoBC,OAApB,CAA4B,wBAA5B,IAAwDE,MAAM,CAACG,QAA/D;AACD;AACF,GA5CoC;;AA8CrC;;;;AAIA;;;;;;;;;;;;;;;;;;AAkBAF,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BG,IAA1B,EAAgC;AAChD,QAAI,CAAChC,GAAG,CAACE,IAAJ,CAAS+B,MAAT,CAAgBC,QAAhB,CAAyBF,IAAzB,CAAL,EAAqCA,IAAI,GAAG,IAAIhC,GAAG,CAACE,IAAJ,CAAS+B,MAAb,CAAoBD,IAApB,CAAP;AAErC,QAAIG,EAAE,GAAG,OAAO,IAAhB;AACA,QAAIP,MAAM,GAAG,EAAb;AACA,QAAIQ,IAAI,GAAGpC,GAAG,CAACE,IAAJ,CAASmC,MAAT,CAAgBC,UAAhB,CAA2B,QAA3B,CAAX,CALgD,CAOhD;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACQ,MAAzB,EAAiCD,CAAC,IAAIJ,EAAtC,EAA0C;AACxC,UAAIM,KAAK,GAAGT,IAAI,CAACU,KAAL,CAAWH,CAAX,EAAcI,IAAI,CAACC,GAAL,CAASL,CAAC,GAAGJ,EAAb,EAAiBH,IAAI,CAACQ,MAAtB,CAAd,CAAZ;AACAJ,MAAAA,IAAI,CAACjC,MAAL,CAAYsC,KAAZ;AACAb,MAAAA,MAAM,CAACiB,IAAP,CAAY7C,GAAG,CAACE,IAAJ,CAASmC,MAAT,CAAgBS,MAAhB,CAAuBL,KAAvB,CAAZ;AACD;;AAED,WAAO;AACLX,MAAAA,UAAU,EAAEM,IAAI,CAACW,MAAL,CAAY,KAAZ,CADP;AAELhB,MAAAA,QAAQ,EAAE,KAAKiB,aAAL,CAAmBpB,MAAnB;AAFL,KAAP;AAID,GAtFoC;;AAwFrC;;;AAGAoB,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBpB,MAAvB,EAA+B;AAC5C;AACA,WAAOA,MAAM,CAACY,MAAP,GAAgB,CAAvB,EAA0B;AACxB,UAAIS,SAAS,GAAG,EAAhB;;AACA,WAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,MAAM,CAACY,MAA3B,EAAmCD,CAAC,IAAI,CAAxC,EAA2C;AACzC,YAAIX,MAAM,CAACW,CAAC,GAAG,CAAL,CAAV,EAAmB;AACjB,cAAIW,OAAO,GAAG,IAAIlD,GAAG,CAACE,IAAJ,CAAS+B,MAAb,CAAoB,EAApB,CAAd;AACAiB,UAAAA,OAAO,CAACC,KAAR,CAAcvB,MAAM,CAACW,CAAD,CAApB,EAAyB,CAAzB,EAA4B,EAA5B,EAAgC,QAAhC;AACAW,UAAAA,OAAO,CAACC,KAAR,CAAcvB,MAAM,CAACW,CAAC,GAAG,CAAL,CAApB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,QAArC;AACAU,UAAAA,SAAS,CAACJ,IAAV,CAAe7C,GAAG,CAACE,IAAJ,CAASmC,MAAT,CAAgBS,MAAhB,CAAuBI,OAAvB,CAAf;AACD,SALD,MAKO;AACLD,UAAAA,SAAS,CAACJ,IAAV,CAAejB,MAAM,CAACW,CAAD,CAArB;AACD;AACF;;AACDX,MAAAA,MAAM,GAAGqB,SAAT;AACD;;AAED,WAAOjD,GAAG,CAACE,IAAJ,CAASmC,MAAT,CAAgBe,KAAhB,CAAsBxB,MAAM,CAAC,CAAD,CAA5B,CAAP;AACD;AA7GoC,CAAvC","sourcesContent":["var AWS = require('../core');\n\nAWS.util.update(AWS.Glacier.prototype, {\n  /**\n   * @api private\n   */\n  setupRequestListeners: function setupRequestListeners(request) {\n    if (Array.isArray(request._events.validate)) {\n      request._events.validate.unshift(this.validateAccountId);\n    } else {\n      request.on('validate', this.validateAccountId);\n    }\n\n    request.on('build', this.addGlacierApiVersion);\n    request.on('build', this.addTreeHashHeaders);\n  },\n\n  /**\n   * @api private\n   */\n  validateAccountId: function validateAccountId(request) {\n    if (request.params.accountId !== undefined) return;\n    request.params = AWS.util.copy(request.params);\n    request.params.accountId = '-';\n  },\n\n  /**\n   * @api private\n   */\n  addGlacierApiVersion: function addGlacierApiVersion(request) {\n    var version = request.service.api.apiVersion;\n    request.httpRequest.headers['x-amz-glacier-version'] = version;\n  },\n\n  /**\n   * @api private\n   */\n  addTreeHashHeaders: function addTreeHashHeaders(request) {\n    if (request.params.body === undefined) return;\n\n    var hashes = request.service.computeChecksums(request.params.body);\n    request.httpRequest.headers['x-amz-content-sha256'] = hashes.linearHash;\n\n    if (!request.httpRequest.headers['x-amz-sha256-tree-hash']) {\n      request.httpRequest.headers['x-amz-sha256-tree-hash'] = hashes.treeHash;\n    }\n  },\n\n  /**\n   * @!group Computing Checksums\n   */\n\n  /**\n   * Computes the SHA-256 linear and tree hash checksums for a given\n   * block of Buffer data. Pass the tree hash of the computed checksums\n   * as the checksum input to the {completeMultipartUpload} when performing\n   * a multi-part upload.\n   *\n   * @example Calculate checksum of 5.5MB data chunk\n   *   var glacier = new AWS.Glacier();\n   *   var data = new Buffer(5.5 * 1024 * 1024);\n   *   data.fill('0'); // fill with zeros\n   *   var results = glacier.computeChecksums(data);\n   *   // Result: { linearHash: '68aff0c5a9...', treeHash: '154e26c78f...' }\n   * @param data [Buffer, String] data to calculate the checksum for\n   * @return [map<linearHash:String,treeHash:String>] a map containing\n   *   the linearHash and treeHash properties representing hex based digests\n   *   of the respective checksums.\n   * @see completeMultipartUpload\n   */\n  computeChecksums: function computeChecksums(data) {\n    if (!AWS.util.Buffer.isBuffer(data)) data = new AWS.util.Buffer(data);\n\n    var mb = 1024 * 1024;\n    var hashes = [];\n    var hash = AWS.util.crypto.createHash('sha256');\n\n    // build leaf nodes in 1mb chunks\n    for (var i = 0; i < data.length; i += mb) {\n      var chunk = data.slice(i, Math.min(i + mb, data.length));\n      hash.update(chunk);\n      hashes.push(AWS.util.crypto.sha256(chunk));\n    }\n\n    return {\n      linearHash: hash.digest('hex'),\n      treeHash: this.buildHashTree(hashes)\n    };\n  },\n\n  /**\n   * @api private\n   */\n  buildHashTree: function buildHashTree(hashes) {\n    // merge leaf nodes\n    while (hashes.length > 1) {\n      var tmpHashes = [];\n      for (var i = 0; i < hashes.length; i += 2) {\n        if (hashes[i + 1]) {\n          var tmpHash = new AWS.util.Buffer(64);\n          tmpHash.write(hashes[i], 0, 32, 'binary');\n          tmpHash.write(hashes[i + 1], 32, 32, 'binary');\n          tmpHashes.push(AWS.util.crypto.sha256(tmpHash));\n        } else {\n          tmpHashes.push(hashes[i]);\n        }\n      }\n      hashes = tmpHashes;\n    }\n\n    return AWS.util.crypto.toHex(hashes[0]);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview This is the main file for the RAI library to create text based servers\n * @author <a href=\"mailto:andris@node.ee\">Andris Reinman</a>\n */\n\nvar netlib = require(\"net\"),\n    utillib = require(\"util\"),\n    EventEmitter = require('events').EventEmitter,\n    starttls = require(\"./starttls\").starttls,\n    tlslib = require(\"tls\"),\n    fs = require(\"fs\"),\n    SlowBuffer = require(\"buffer\").SlowBuffer; // Default credentials for starting TLS server\n\n\nvar defaultCredentials = {\n  key: fs.readFileSync(__dirname + \"/../cert/server.key\"),\n  cert: fs.readFileSync(__dirname + \"/../cert/server.crt\")\n}; // Expose to the world\n\nmodule.exports.RAIServer = RAIServer;\nmodule.exports.runClientMockup = require(\"./mockup\");\n/**\n * <p>Creates instance of RAIServer</p>\n *\n * <p>Options object has the following properties:</p>\n *\n * <ul>\n *   <li><b>debug</b> - if set to true print traffic to console</li>\n *   <li><b>disconnectOnTimeout</b> - if set to true close the connection on disconnect</li>\n *   <li><b>secureConnection</b> - if set to true close the connection on disconnect</li>\n *   <li><b>credentials</b> - credentials for secureConnection and STARTTLS</li>\n *   <li><b>timeout</b> - timeout in milliseconds for disconnecting the client,\n *       defaults to 0 (no timeout)</li>\n * </ul>\n *\n * <p><b>Events</b></p>\n *\n * <ul>\n *     <li><b>'connect'</b> - emitted if a client connects to the server, param\n *         is a client ({@link RAISocket}) object</li>\n *     <li><b>'error'</b> - emitted on error, has an error object as a param</li>\n * </ul>\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\n\nfunction RAIServer(options) {\n  EventEmitter.call(this);\n  this.options = options || {};\n\n  if (this.options.debug) {\n    this._logger = this.options.debug === true ? console.log : this.options.debug;\n  } else {\n    this._logger = function () {};\n  }\n\n  this._createServer();\n}\n\nutillib.inherits(RAIServer, EventEmitter);\n/**\n * <p>Starts listening on selected port</p>\n *\n * @param {Number} port The port to listen\n * @param {String} [host] The IP address to listen\n * @param {Function} callback The callback function to be run after the server\n * is listening, the only param is an error message if the operation failed\n */\n\nRAIServer.prototype.listen = function (port, host, callback) {\n  if (!callback && typeof host == \"function\") {\n    callback = host;\n    host = undefined;\n  }\n\n  this._port = port;\n  this._host = host;\n  this._connected = false;\n\n  if (callback) {\n    this._server.on(\"listening\", function () {\n      this._connected = true;\n      callback(null);\n    }.bind(this));\n\n    this._server.on(\"error\", function (err) {\n      if (!this._connected) {\n        callback(err);\n      }\n    }.bind(this));\n  }\n\n  this._server.listen(this._port, this._host);\n};\n/**\n * <p>Stops the server</p>\n *\n * @param {Function} callback Is run when the server is closed\n */\n\n\nRAIServer.prototype.end = function (callback) {\n  this._server.on(\"close\", callback);\n\n  this._server.close();\n};\n/**\n * <p>Creates a server with listener callback</p>\n */\n\n\nRAIServer.prototype._createServer = function () {\n  if (this.options.secureConnection) {\n    this._server = tlslib.createServer(this.options.credentials || defaultCredentials, this._serverListener.bind(this));\n  } else {\n    this._server = netlib.createServer(this._serverListener.bind(this));\n  }\n\n  this._server.on(\"error\", this._onError.bind(this));\n};\n/**\n * <p>Listens for errors</p>\n *\n * @event\n * @param {Object} err Error object\n */\n\n\nRAIServer.prototype._onError = function (err) {\n  if (this._connected) {\n    this.emit(\"error\", err);\n  }\n};\n/**\n * <p>Server listener that is run on client connection</p>\n *\n * <p>{@link RAISocket} object instance is created based on the client socket\n *    and a <code>'connection'</code> event is emitted</p>\n *\n * @param {Object} socket The socket to the client\n */\n\n\nRAIServer.prototype._serverListener = function (socket) {\n  this._logger(\"CONNECTION FROM \" + socket.remoteAddress);\n\n  var handler = new RAISocket(socket, this.options);\n  socket.on(\"data\", handler._onReceiveData.bind(handler));\n  socket.on(\"end\", handler._onEnd.bind(handler));\n  socket.on(\"error\", handler._onError.bind(handler));\n  socket.on(\"timeout\", handler._onTimeout.bind(handler));\n  socket.on(\"close\", handler._onClose.bind(handler));\n\n  if (\"setKeepAlive\" in socket) {\n    socket.setKeepAlive(true); // plaintext server\n  } else if (socket.encrypted && \"setKeepAlive\" in socket.encrypted) {\n    socket.encrypted.setKeepAlive(true); // secure server\n  }\n\n  this.emit(\"connect\", handler);\n};\n/**\n * <p>Creates a instance for interacting with a client (socket)</p>\n *\n * <p>Optional options object is the same that is passed to the parent\n * {@link RAIServer} object</p>\n *\n * <p><b>Events</b></p>\n *\n * <ul>\n *     <li><b>'command'</b> - emitted if a client sends a command. Gets two\n *         params - command (String) and payload (Buffer)</li>\n *     <li><b>'data'</b> - emitted when a chunk is received in data mode, the\n *         param being the payload (Buffer)</li>\n *     <li><b>'ready'</b> - emitted when data stream ends and normal command\n *         flow is recovered</li>\n *     <li><b>'tls'</b> - emitted when the connection is secured by TLS</li>\n *     <li><b>'error'</b> - emitted when an error occurs. Connection to the\n *         client is disconnected automatically. Param is an error object.</l>\n *     <li><b>'timeout'</b> - emitted when a timeout occurs. Connection to the\n *         client is disconnected automatically if disconnectOnTimeout option\n *         is set to true.</l>\n *     <li><b>'end'</b> - emitted when the client disconnects</l>\n * </ul>\n *\n * @constructor\n * @param {Object} socket Socket for the client\n * @param {Object} [options] Optional options object\n */\n\n\nfunction RAISocket(socket, options) {\n  EventEmitter.call(this);\n  this.socket = socket;\n  this.options = options || {};\n\n  if (this.options.debug) {\n    this._logger = this.options.debug === true ? console.log : this.options.debug;\n  } else {\n    this._logger = function () {};\n  }\n\n  this.remoteAddress = socket.remoteAddress;\n  this._dataMode = false;\n  this._endDataModeSequence = \"\\r\\n.\\r\\n\";\n  this._endDataModeSequenceRegEx = /\\r\\n\\.\\r\\n/;\n  this.secureConnection = !!this.options.secureConnection;\n  this._destroyed = false;\n  this._remainder = \"\";\n  this._ignore_data = false;\n\n  if (this.options.timeout) {\n    socket.setTimeout(this.options.timeout);\n  }\n}\n\nutillib.inherits(RAISocket, EventEmitter);\n/**\n * <p>Sends some data to the client. <code>&lt;CR&gt;&lt;LF&gt;</code> is automatically appended to\n *    the data</p>\n *\n * @param {String|Buffer} data Data to be sent to the client\n */\n\nRAISocket.prototype.send = function (data) {\n  var buffer;\n\n  if (data instanceof Buffer || data instanceof SlowBuffer) {\n    buffer = new Buffer(data.length + 2);\n    buffer[buffer.length - 2] = 0xD;\n    buffer[buffer.length - 1] = 0xA;\n    data.copy(buffer);\n  } else {\n    buffer = new Buffer((data || \"\").toString() + \"\\r\\n\", \"binary\");\n  }\n\n  this._logger(\"OUT: \\\"\" + buffer.toString(\"utf-8\").trim() + \"\\\"\");\n\n  if (this.socket && this.socket.writable) {\n    this.socket.write(buffer);\n  } else {\n    this.socket.end();\n  }\n};\n/**\n * <p>Instructs the server to be listening for mixed data instead of line based\n *    commands</p>\n *\n * @param {String} [sequence=\".\"] - optional sequence on separate line for\n *        matching the data end\n */\n\n\nRAISocket.prototype.startDataMode = function (sequence) {\n  this._dataMode = true;\n\n  if (sequence) {\n    sequence = sequence.replace(/([\\.\\=\\(\\)\\-\\?\\*\\\\\\[\\]\\^\\+\\:\\|\\,])/g, \"\\\\$1\");\n    this._endDataModeSequence = \"\\r\\n\" + sequence + \"\\r\\n\";\n    this._endDataModeSequenceRegEx = new RegExp(\"\\\\r\\\\n\" + sequence + \"\\\\r\\\\n\");\n  }\n};\n/**\n * <p>Instructs the server to upgrade the connection to secure TLS connection</p>\n *\n * <p>Fires <code>callback</code> on successful connection upgrade if set,\n * otherwise emits <code>'tls'</code></p>\n *\n * @param {Object} [credentials] An object with PEM encoded key and\n *        certificate <code>{key:\"---BEGIN...\", cert:\"---BEGIN...\"}</code>,\n *        if not set autogenerated values will be used.\n * @param {Function} [callback] If calback is set fire it after successful connection\n *        upgrade, otherwise <code>'tls'</code> is emitted\n */\n\n\nRAISocket.prototype.startTLS = function (credentials, callback) {\n  if (this.secureConnection) {\n    return this._onError(new Error(\"Secure connection already established\"));\n  }\n\n  if (!callback && typeof credentials == \"function\") {\n    callback = credentials;\n    credentials = undefined;\n  }\n\n  credentials = credentials || this.options.credentials || defaultCredentials;\n  this._ignore_data = true;\n  var secure_connector = starttls(this.socket, credentials, function (ssl_socket) {\n    if (!ssl_socket.authorized) {\n      this._logger(\"WARNING: TLS ERROR (\" + ssl_socket.authorizationError + \")\");\n    }\n\n    this._remainder = \"\";\n    this._ignore_data = false;\n    this.secureConnection = true;\n    this.socket = ssl_socket;\n    this.socket.on(\"data\", this._onReceiveData.bind(this));\n    this.socket.on(\"error\", this._onError.bind(this));\n\n    this._logger(\"TLS CONNECTION STARTED\");\n\n    if (callback) {\n      callback();\n    } else {\n      this.emit(\"tls\");\n    }\n  }.bind(this));\n  secure_connector.on(\"error\", function (err) {\n    this._onError(err);\n  }.bind(this));\n};\n/**\n * <p>Closes the connection to the client</p>\n */\n\n\nRAISocket.prototype.end = function () {\n  this.socket.end();\n};\n/**\n * <p>Called when a chunk of data arrives from the client. If currently in data\n * mode, transmit the data otherwise send it to <code>_processData</code></p>\n *\n * @event\n * @param {Buffer|String} chunk Data sent by the client\n */\n\n\nRAISocket.prototype._onReceiveData = function (chunk) {\n  if (this._ignore_data) {\n    // if currently setting up TLS connection\n    return;\n  }\n\n  var str = typeof chunk == \"string\" ? chunk : chunk.toString(\"binary\"),\n      dataRemainderMatch,\n      data;\n\n  if (this._dataMode) {\n    // prefix the incoming chunk with the remainder of the previous chunk\n    str = this._remainder + str;\n    this._remainder = \"\"; // check if a data end sequence is found from the data\n\n    if (dataRemainderMatch = str.match(this._endDataModeSequenceRegEx)) {\n      // if the sequence is not on byte 0 emit remaining data\n      if (dataRemainderMatch.index) {\n        data = new Buffer(str.substr(0, dataRemainderMatch.index), \"binary\");\n\n        this._logger(\"DATA:\", data.toString(\"utf-8\"));\n\n        this.emit(\"data\", data);\n      } // emit data ready\n\n\n      this.emit(\"ready\");\n      this._dataMode = false; // send the remaining data for processing\n\n      this._processData(str.substr(dataRemainderMatch.index + dataRemainderMatch[0].length) + \"\\r\\n\");\n    } else {\n      // check if there's not something in the end of the data that resembles\n      // end sequence - if so, cut it off and save it to the remainder\n      for (var i = Math.min(this._endDataModeSequence.length - 1, str.length); i > 0; i--) {\n        if (str.substr(-i) == this._endDataModeSequence.substr(0, i)) {\n          this._remainder = str.substr(-i);\n          str = str.substr(0, str.length - i);\n        }\n      } // if there's some data left, emit it\n\n\n      if (str.length) {\n        data = new Buffer(str, \"binary\");\n\n        this._logger(\"DATA:\", data.toString(\"utf-8\"));\n\n        this.emit(\"data\", data);\n      }\n    }\n  } else {\n    // Not in data mode, process as command\n    this._processData(str);\n  }\n};\n/**\n * <p>Processed incoming command lines and emits found data as\n * <code>'command'</code> with the command name as the first param and the rest\n * of the data as second (Buffer)</p>\n *\n * @param {String} str Binary string to be processed\n */\n\n\nRAISocket.prototype._processData = function (str) {\n  var lines = (this._remainder + str).split(\"\\r\\n\"),\n      match,\n      command;\n  this._remainder = lines.pop();\n\n  for (var i = 0, len = lines.length; i < len; i++) {\n    if (this._ignore_data) {\n      // If TLS upgrade is initiated do not process current buffer\n      this._remainder = \"\";\n      break;\n    }\n\n    if (!this._dataMode) {\n      if ((match = lines[i].match(/\\s*[\\S]+\\s?/)) || (match = lines[i].match(/^$/))) {\n        command = (match[0] || \"\").trim();\n\n        this._logger(\"COMMAND:\", lines[i]);\n\n        this.emit(\"command\", command, new Buffer(lines[i].substr(match.index + match[0].length), \"binary\"));\n      }\n    } else {\n      if (this._remainder) {\n        this._remainder += \"\\r\\n\";\n      }\n\n      this._onReceiveData(lines.slice(i).join(\"\\r\\n\"));\n\n      break;\n    }\n  }\n};\n/**\n * <p>Called when the connection is or is going to be ended</p>\n */\n\n\nRAISocket.prototype._destroy = function () {\n  if (this._destroyed) {\n    return;\n  }\n\n  this._destroyed = true;\n  this.removeAllListeners();\n};\n/**\n * <p>Called when the connection is ended. Emits <code>'end'</code></p>\n *\n * @event\n */\n\n\nRAISocket.prototype._onEnd = function () {\n  this.emit(\"end\");\n\n  this._destroy();\n};\n/**\n * <p>Called when an error has appeared. Emits <code>'error'</code> with\n * the error object as a parameter.</p>\n *\n * @event\n * @param {Object} err Error object\n */\n\n\nRAISocket.prototype._onError = function (err) {\n  this.emit(\"error\", err);\n\n  this._destroy();\n};\n/**\n * <p>Called when a timeout has occured. Connection will be closed and\n * <code>'timeout'</code> is emitted.</p>\n *\n * @event\n */\n\n\nRAISocket.prototype._onTimeout = function () {\n  if (this.options.disconnectOnTimeout) {\n    if (this.socket && !this.socket.destroyed) {\n      this.socket.end();\n    }\n\n    this.emit(\"timeout\");\n\n    this._destroy();\n  } else {\n    this.emit(\"timeout\");\n  }\n};\n/**\n * <p>Called when the connection is closed</p>\n *\n * @event\n * @param {Boolean} hadError did the connection end because of an error?\n */\n\n\nRAISocket.prototype._onClose = function ()\n/* hadError */\n{\n  this._destroy();\n};","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/rai/lib/rai.js"],"names":["netlib","require","utillib","EventEmitter","starttls","tlslib","fs","SlowBuffer","defaultCredentials","key","readFileSync","__dirname","cert","module","exports","RAIServer","runClientMockup","options","call","debug","_logger","console","log","_createServer","inherits","prototype","listen","port","host","callback","undefined","_port","_host","_connected","_server","on","bind","err","end","close","secureConnection","createServer","credentials","_serverListener","_onError","emit","socket","remoteAddress","handler","RAISocket","_onReceiveData","_onEnd","_onTimeout","_onClose","setKeepAlive","encrypted","_dataMode","_endDataModeSequence","_endDataModeSequenceRegEx","_destroyed","_remainder","_ignore_data","timeout","setTimeout","send","data","buffer","Buffer","length","copy","toString","trim","writable","write","startDataMode","sequence","replace","RegExp","startTLS","Error","secure_connector","ssl_socket","authorized","authorizationError","chunk","str","dataRemainderMatch","match","index","substr","_processData","i","Math","min","lines","split","command","pop","len","slice","join","_destroy","removeAllListeners","disconnectOnTimeout","destroyed"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * @fileOverview This is the main file for the RAI library to create text based servers\n * @author <a href=\"mailto:andris@node.ee\">Andris Reinman</a>\n */\n\nvar netlib = require(\"net\"),\n    utillib = require(\"util\"),\n    EventEmitter = require('events').EventEmitter,\n    starttls = require(\"./starttls\").starttls,\n    tlslib = require(\"tls\"),\n    fs = require(\"fs\"),\n    SlowBuffer = require(\"buffer\").SlowBuffer;\n\n// Default credentials for starting TLS server\nvar defaultCredentials = {\n    key: fs.readFileSync(__dirname+\"/../cert/server.key\"),\n    cert: fs.readFileSync(__dirname+\"/../cert/server.crt\")\n};\n\n// Expose to the world\nmodule.exports.RAIServer = RAIServer;\nmodule.exports.runClientMockup = require(\"./mockup\");\n\n/**\n * <p>Creates instance of RAIServer</p>\n *\n * <p>Options object has the following properties:</p>\n *\n * <ul>\n *   <li><b>debug</b> - if set to true print traffic to console</li>\n *   <li><b>disconnectOnTimeout</b> - if set to true close the connection on disconnect</li>\n *   <li><b>secureConnection</b> - if set to true close the connection on disconnect</li>\n *   <li><b>credentials</b> - credentials for secureConnection and STARTTLS</li>\n *   <li><b>timeout</b> - timeout in milliseconds for disconnecting the client,\n *       defaults to 0 (no timeout)</li>\n * </ul>\n *\n * <p><b>Events</b></p>\n *\n * <ul>\n *     <li><b>'connect'</b> - emitted if a client connects to the server, param\n *         is a client ({@link RAISocket}) object</li>\n *     <li><b>'error'</b> - emitted on error, has an error object as a param</li>\n * </ul>\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nfunction RAIServer(options){\n    EventEmitter.call(this);\n\n    this.options = options || {};\n\n    if (this.options.debug) {\n        this._logger = this.options.debug === true ? console.log : this.options.debug;\n    } else {\n        this._logger = function(){};\n    }\n\n    this._createServer();\n}\nutillib.inherits(RAIServer, EventEmitter);\n\n/**\n * <p>Starts listening on selected port</p>\n *\n * @param {Number} port The port to listen\n * @param {String} [host] The IP address to listen\n * @param {Function} callback The callback function to be run after the server\n * is listening, the only param is an error message if the operation failed\n */\nRAIServer.prototype.listen = function(port, host, callback){\n    if(!callback && typeof host==\"function\"){\n        callback = host;\n        host = undefined;\n    }\n    this._port = port;\n    this._host = host;\n\n    this._connected = false;\n    if(callback){\n        this._server.on(\"listening\", (function(){\n            this._connected = true;\n            callback(null);\n        }).bind(this));\n\n        this._server.on(\"error\", (function(err){\n            if(!this._connected){\n                callback(err);\n            }\n        }).bind(this));\n    }\n\n    this._server.listen(this._port, this._host);\n};\n\n/**\n * <p>Stops the server</p>\n *\n * @param {Function} callback Is run when the server is closed\n */\nRAIServer.prototype.end = function(callback){\n    this._server.on(\"close\", callback);\n    this._server.close();\n};\n\n/**\n * <p>Creates a server with listener callback</p>\n */\nRAIServer.prototype._createServer = function(){\n    if(this.options.secureConnection){\n        this._server = tlslib.createServer(\n            this.options.credentials || defaultCredentials,\n            this._serverListener.bind(this));\n    }else{\n        this._server = netlib.createServer(this._serverListener.bind(this));\n    }\n    this._server.on(\"error\", this._onError.bind(this));\n};\n\n/**\n * <p>Listens for errors</p>\n *\n * @event\n * @param {Object} err Error object\n */\nRAIServer.prototype._onError = function(err){\n    if(this._connected){\n        this.emit(\"error\", err);\n    }\n};\n\n/**\n * <p>Server listener that is run on client connection</p>\n *\n * <p>{@link RAISocket} object instance is created based on the client socket\n *    and a <code>'connection'</code> event is emitted</p>\n *\n * @param {Object} socket The socket to the client\n */\nRAIServer.prototype._serverListener = function(socket){\n    this._logger(\"CONNECTION FROM \"+socket.remoteAddress);\n\n    var handler = new RAISocket(socket, this.options);\n\n    socket.on(\"data\", handler._onReceiveData.bind(handler));\n    socket.on(\"end\", handler._onEnd.bind(handler));\n    socket.on(\"error\", handler._onError.bind(handler));\n    socket.on(\"timeout\", handler._onTimeout.bind(handler));\n    socket.on(\"close\", handler._onClose.bind(handler));\n\n    if(\"setKeepAlive\" in socket){\n        socket.setKeepAlive(true); // plaintext server\n    }else if(socket.encrypted && \"setKeepAlive\" in socket.encrypted){\n        socket.encrypted.setKeepAlive(true); // secure server\n    }\n\n    this.emit(\"connect\", handler);\n};\n\n/**\n * <p>Creates a instance for interacting with a client (socket)</p>\n *\n * <p>Optional options object is the same that is passed to the parent\n * {@link RAIServer} object</p>\n *\n * <p><b>Events</b></p>\n *\n * <ul>\n *     <li><b>'command'</b> - emitted if a client sends a command. Gets two\n *         params - command (String) and payload (Buffer)</li>\n *     <li><b>'data'</b> - emitted when a chunk is received in data mode, the\n *         param being the payload (Buffer)</li>\n *     <li><b>'ready'</b> - emitted when data stream ends and normal command\n *         flow is recovered</li>\n *     <li><b>'tls'</b> - emitted when the connection is secured by TLS</li>\n *     <li><b>'error'</b> - emitted when an error occurs. Connection to the\n *         client is disconnected automatically. Param is an error object.</l>\n *     <li><b>'timeout'</b> - emitted when a timeout occurs. Connection to the\n *         client is disconnected automatically if disconnectOnTimeout option\n *         is set to true.</l>\n *     <li><b>'end'</b> - emitted when the client disconnects</l>\n * </ul>\n *\n * @constructor\n * @param {Object} socket Socket for the client\n * @param {Object} [options] Optional options object\n */\nfunction RAISocket(socket, options){\n    EventEmitter.call(this);\n\n    this.socket = socket;\n    this.options = options || {};\n\n    if (this.options.debug) {\n        this._logger = this.options.debug === true ? console.log : this.options.debug;\n    } else {\n        this._logger = function(){};\n    }\n\n    this.remoteAddress = socket.remoteAddress;\n\n    this._dataMode = false;\n    this._endDataModeSequence = \"\\r\\n.\\r\\n\";\n    this._endDataModeSequenceRegEx = /\\r\\n\\.\\r\\n/;\n\n    this.secureConnection = !!this.options.secureConnection;\n    this._destroyed = false;\n    this._remainder = \"\";\n\n    this._ignore_data = false;\n\n    if(this.options.timeout){\n        socket.setTimeout(this.options.timeout);\n    }\n}\nutillib.inherits(RAISocket, EventEmitter);\n\n/**\n * <p>Sends some data to the client. <code>&lt;CR&gt;&lt;LF&gt;</code> is automatically appended to\n *    the data</p>\n *\n * @param {String|Buffer} data Data to be sent to the client\n */\nRAISocket.prototype.send = function(data){\n    var buffer;\n    if(data instanceof Buffer || data instanceof SlowBuffer){\n        buffer = new Buffer(data.length+2);\n        buffer[buffer.length-2] = 0xD;\n        buffer[buffer.length-1] = 0xA;\n        data.copy(buffer);\n    }else{\n        buffer = new Buffer((data || \"\").toString()+\"\\r\\n\", \"binary\");\n    }\n\n    this._logger(\"OUT: \\\"\" +buffer.toString(\"utf-8\").trim()+\"\\\"\");\n\n    if(this.socket && this.socket.writable){\n        this.socket.write(buffer);\n    }else{\n        this.socket.end();\n    }\n};\n\n/**\n * <p>Instructs the server to be listening for mixed data instead of line based\n *    commands</p>\n *\n * @param {String} [sequence=\".\"] - optional sequence on separate line for\n *        matching the data end\n */\nRAISocket.prototype.startDataMode = function(sequence){\n    this._dataMode = true;\n    if(sequence){\n        sequence = sequence.replace(/([\\.\\=\\(\\)\\-\\?\\*\\\\\\[\\]\\^\\+\\:\\|\\,])/g, \"\\\\$1\");\n        this._endDataModeSequence = \"\\r\\n\"+sequence+\"\\r\\n\";\n        this._endDataModeSequenceRegEx = new RegExp(\"\\\\r\\\\n\" + sequence + \"\\\\r\\\\n\");\n    }\n};\n\n/**\n * <p>Instructs the server to upgrade the connection to secure TLS connection</p>\n *\n * <p>Fires <code>callback</code> on successful connection upgrade if set,\n * otherwise emits <code>'tls'</code></p>\n *\n * @param {Object} [credentials] An object with PEM encoded key and\n *        certificate <code>{key:\"---BEGIN...\", cert:\"---BEGIN...\"}</code>,\n *        if not set autogenerated values will be used.\n * @param {Function} [callback] If calback is set fire it after successful connection\n *        upgrade, otherwise <code>'tls'</code> is emitted\n */\nRAISocket.prototype.startTLS = function(credentials, callback){\n\n    if(this.secureConnection){\n        return this._onError(new Error(\"Secure connection already established\"));\n    }\n\n    if(!callback && typeof credentials == \"function\"){\n        callback = credentials;\n        credentials = undefined;\n    }\n\n    credentials = credentials || this.options.credentials || defaultCredentials;\n\n    this._ignore_data = true;\n\n    var secure_connector = starttls(this.socket, credentials, (function(ssl_socket){\n\n        if(!ssl_socket.authorized){\n            this._logger(\"WARNING: TLS ERROR (\"+ssl_socket.authorizationError+\")\");\n        }\n\n        this._remainder = \"\";\n        this._ignore_data = false;\n\n        this.secureConnection = true;\n\n        this.socket = ssl_socket;\n        this.socket.on(\"data\", this._onReceiveData.bind(this));\n        this.socket.on(\"error\", this._onError.bind(this));\n\n        this._logger(\"TLS CONNECTION STARTED\");\n\n        if(callback){\n            callback();\n        }else{\n            this.emit(\"tls\");\n        }\n\n    }).bind(this));\n\n    secure_connector.on(\"error\", (function(err){\n        this._onError(err);\n    }).bind(this));\n};\n\n/**\n * <p>Closes the connection to the client</p>\n */\nRAISocket.prototype.end = function(){\n    this.socket.end();\n};\n\n/**\n * <p>Called when a chunk of data arrives from the client. If currently in data\n * mode, transmit the data otherwise send it to <code>_processData</code></p>\n *\n * @event\n * @param {Buffer|String} chunk Data sent by the client\n */\nRAISocket.prototype._onReceiveData = function(chunk){\n\n    if(this._ignore_data){ // if currently setting up TLS connection\n        return;\n    }\n\n    var str = typeof chunk==\"string\"?chunk:chunk.toString(\"binary\"),\n        dataRemainderMatch, data;\n\n    if(this._dataMode){\n\n        // prefix the incoming chunk with the remainder of the previous chunk\n        str = this._remainder + str;\n        this._remainder = \"\";\n\n        // check if a data end sequence is found from the data\n        if((dataRemainderMatch = str.match(this._endDataModeSequenceRegEx))){\n            // if the sequence is not on byte 0 emit remaining data\n            if(dataRemainderMatch.index){\n                data = new Buffer(str.substr(0, dataRemainderMatch.index), \"binary\");\n                this._logger(\"DATA:\", data.toString(\"utf-8\"));\n                this.emit(\"data\", data);\n            }\n            // emit data ready\n            this.emit(\"ready\");\n            this._dataMode = false;\n            // send the remaining data for processing\n            this._processData(str.substr(dataRemainderMatch.index + dataRemainderMatch[0].length)+\"\\r\\n\");\n        }else{\n            // check if there's not something in the end of the data that resembles\n            // end sequence - if so, cut it off and save it to the remainder\n            for(var i = Math.min(this._endDataModeSequence.length-1, str.length); i>0; i--){\n                if(str.substr(-i) == this._endDataModeSequence.substr(0, i)){\n                    this._remainder = str.substr(-i);\n                    str = str.substr(0, str.length - i);\n                }\n            }\n\n            // if there's some data left, emit it\n            if(str.length){\n                data = new Buffer(str, \"binary\");\n                this._logger(\"DATA:\", data.toString(\"utf-8\"));\n                this.emit(\"data\", data);\n            }\n        }\n    }else{\n        // Not in data mode, process as command\n        this._processData(str);\n    }\n};\n\n/**\n * <p>Processed incoming command lines and emits found data as\n * <code>'command'</code> with the command name as the first param and the rest\n * of the data as second (Buffer)</p>\n *\n * @param {String} str Binary string to be processed\n */\nRAISocket.prototype._processData = function(str){\n    var lines = (this._remainder+str).split(\"\\r\\n\"),\n        match, command;\n\n    this._remainder = lines.pop();\n\n    for(var i=0, len = lines.length; i<len; i++){\n        if(this._ignore_data){\n            // If TLS upgrade is initiated do not process current buffer\n            this._remainder = \"\";\n            break;\n        }\n        if(!this._dataMode){\n            if((match = lines[i].match(/\\s*[\\S]+\\s?/)) || (match = lines[i].match(/^$/))){\n                command = (match[0] || \"\").trim();\n                this._logger(\"COMMAND:\", lines[i]);\n                this.emit(\"command\", command, new Buffer(lines[i].substr(match.index + match[0].length), \"binary\"));\n            }\n        }else{\n            if(this._remainder){\n                this._remainder += \"\\r\\n\";\n            }\n            this._onReceiveData(lines.slice(i).join(\"\\r\\n\"));\n            break;\n        }\n    }\n};\n\n/**\n * <p>Called when the connection is or is going to be ended</p>\n */\nRAISocket.prototype._destroy = function(){\n    if(this._destroyed){\n        return;\n    }\n    this._destroyed = true;\n\n    this.removeAllListeners();\n};\n\n/**\n * <p>Called when the connection is ended. Emits <code>'end'</code></p>\n *\n * @event\n */\nRAISocket.prototype._onEnd = function(){\n    this.emit(\"end\");\n    this._destroy();\n};\n\n/**\n * <p>Called when an error has appeared. Emits <code>'error'</code> with\n * the error object as a parameter.</p>\n *\n * @event\n * @param {Object} err Error object\n */\nRAISocket.prototype._onError = function(err){\n    this.emit(\"error\", err);\n    this._destroy();\n};\n\n/**\n * <p>Called when a timeout has occured. Connection will be closed and\n * <code>'timeout'</code> is emitted.</p>\n *\n * @event\n */\nRAISocket.prototype._onTimeout = function(){\n    if(this.options.disconnectOnTimeout){\n        if(this.socket && !this.socket.destroyed){\n            this.socket.end();\n        }\n        this.emit(\"timeout\");\n        this._destroy();\n    }else{\n        this.emit(\"timeout\");\n    }\n};\n\n/**\n * <p>Called when the connection is closed</p>\n *\n * @event\n * @param {Boolean} hadError did the connection end because of an error?\n */\nRAISocket.prototype._onClose = function(/* hadError */){\n    this._destroy();\n};\n"]},"metadata":{},"sourceType":"script"}
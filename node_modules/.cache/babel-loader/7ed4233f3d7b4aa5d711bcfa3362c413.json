{"ast":null,"code":"var AWS = require('../core');\n\nAWS.util.update(AWS.S3.prototype, {\n  /**\n   * @api private\n   */\n  validateService: function validateService() {\n    // default to us-east-1 when no region is provided\n    if (!this.config.region) this.config.region = 'us-east-1';\n  },\n\n  /**\n   * @api private\n   */\n  setupRequestListeners: function setupRequestListeners(request) {\n    request.addListener('build', this.addContentType);\n    request.addListener('build', this.populateURI);\n    request.addListener('build', this.computeContentMd5);\n    request.addListener('build', this.computeSha256);\n    request.addListener('build', this.computeSseCustomerKeyMd5);\n    request.removeListener('validate', AWS.EventListeners.Core.VALIDATE_REGION);\n    request.addListener('extractError', this.extractError);\n    request.addListener('extractData', this.extractData);\n    request.addListener('beforePresign', this.prepareSignedUrl);\n  },\n\n  /**\n   * S3 prefers dns-compatible bucket names to be moved from the uri path\n   * to the hostname as a sub-domain.  This is not possible, even for dns-compat\n   * buckets when using SSL and the bucket name contains a dot ('.').  The\n   * ssl wildcard certificate is only 1-level deep.\n   *\n   * @api private\n   */\n  populateURI: function populateURI(req) {\n    var httpRequest = req.httpRequest;\n    var b = req.params.Bucket;\n\n    if (b) {\n      if (!req.service.pathStyleBucketName(b)) {\n        httpRequest.endpoint.hostname = b + '.' + httpRequest.endpoint.hostname;\n        var port = httpRequest.endpoint.port;\n\n        if (port !== 80 && port !== 443) {\n          httpRequest.endpoint.host = httpRequest.endpoint.hostname + ':' + httpRequest.endpoint.port;\n        } else {\n          httpRequest.endpoint.host = httpRequest.endpoint.hostname;\n        }\n\n        httpRequest.virtualHostedBucket = b; // needed for signing the request\n\n        httpRequest.path = httpRequest.path.replace(new RegExp('/' + b), '');\n\n        if (httpRequest.path[0] !== '/') {\n          httpRequest.path = '/' + httpRequest.path;\n        }\n      }\n    }\n  },\n\n  /**\n   * Adds a default content type if none is supplied.\n   *\n   * @api private\n   */\n  addContentType: function addContentType(req) {\n    var httpRequest = req.httpRequest;\n\n    if (!httpRequest.headers['Content-Type']) {\n      // always have a Content-Type\n      httpRequest.headers['Content-Type'] = 'application/octet-stream';\n    }\n\n    var contentType = httpRequest.headers['Content-Type'];\n\n    if (AWS.util.isBrowser()) {\n      if (typeof httpRequest.body === 'string' && !contentType.match(/;\\s*charset=/)) {\n        var charset = '; charset=UTF-8';\n        httpRequest.headers['Content-Type'] += charset;\n      } else {\n        var replaceFn = function (_, prefix, charset) {\n          return prefix + charset.toUpperCase();\n        };\n\n        httpRequest.headers['Content-Type'] = contentType.replace(/(;\\s*charset=)(.+)$/, replaceFn);\n      }\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computableChecksumOperations: {\n    putBucketCors: true,\n    putBucketLifecycle: true,\n    putBucketTagging: true,\n    deleteObjects: true\n  },\n\n  /**\n   * Checks whether checksums should be computed for the request.\n   * If the request requires checksums to be computed, this will always\n   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}\n   * is set.\n   *\n   * @param req [AWS.Request] the request to check against\n   * @return [Boolean] whether to compute checksums for a request.\n   * @api private\n   */\n  willComputeChecksums: function willComputeChecksums(req) {\n    if (this.computableChecksumOperations[req.operation]) return true;\n    if (!this.config.computeChecksums) return false; // TODO: compute checksums for Stream objects\n\n    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) && typeof req.httpRequest.body !== 'string') {\n      return false;\n    }\n\n    var rules = req.service.api.operations[req.operation].input.members; // V4 signer uses SHA256 signatures so only compute MD5 if it is required\n\n    if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;\n    }\n\n    if (rules.ContentMD5 && !req.params.ContentMD5) return true;\n  },\n\n  /**\n   * A listener that computes the Content-MD5 and sets it in the header.\n   * @see AWS.S3.willComputeChecksums\n   * @api private\n   */\n  computeContentMd5: function computeContentMd5(req) {\n    if (req.service.willComputeChecksums(req)) {\n      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');\n      req.httpRequest.headers['Content-MD5'] = md5;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computeSha256: function computeSha256(req) {\n    if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n      req.httpRequest.headers['X-Amz-Content-Sha256'] = AWS.util.crypto.sha256(req.httpRequest.body || '', 'hex');\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {\n    var headers = ['x-amz-server-side-encryption-customer-key', 'x-amz-copy-source-server-side-encryption-customer-key'];\n    AWS.util.arrayEach(headers, function (header) {\n      if (req.httpRequest.headers[header]) {\n        var key = req.httpRequest.headers[header];\n        var md5header = header + '-MD5';\n        req.httpRequest.headers[header] = AWS.util.base64.encode(key);\n\n        if (!req.httpRequest.headers[md5header]) {\n          var value = AWS.util.crypto.md5(key, 'base64');\n          req.httpRequest.headers[md5header] = AWS.util.base64.encode(value);\n        }\n      }\n    });\n  },\n\n  /**\n   * Returns true if the bucket name should be left in the URI path for\n   * a request to S3.  This function takes into account the current\n   * endpoint protocol (e.g. http or https).\n   *\n   * @api private\n   */\n  pathStyleBucketName: function pathStyleBucketName(bucketName) {\n    // user can force path style requests via the configuration\n    if (this.config.s3ForcePathStyle) return true;\n\n    if (this.dnsCompatibleBucketName(bucketName)) {\n      return this.config.sslEnabled && bucketName.match(/\\./) ? true : false;\n    } else {\n      return true; // not dns compatible names must always use path style\n    }\n  },\n\n  /**\n   * Returns true if the bucket name is DNS compatible.  Buckets created\n   * outside of the classic region MUST be DNS compatible.\n   *\n   * @api private\n   */\n  dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {\n    var b = bucketName;\n    var domain = new RegExp(/^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/);\n    var ipAddress = new RegExp(/(\\d+\\.){3}\\d+/);\n    var dots = new RegExp(/\\.\\./);\n    return b.match(domain) && !b.match(ipAddress) && !b.match(dots) ? true : false;\n  },\n\n  /**\n   * S3 requires that path params not escape forward slashes.\n   *\n   * @api private\n   */\n  escapePathParam: function escapePathParam(value) {\n    return AWS.util.uriEscapePath(String(value));\n  },\n\n  /**\n   * @return [Boolean] whether response contains an error\n   * @api private\n   */\n  successfulResponse: function successfulResponse(resp) {\n    var req = resp.request;\n    var httpResponse = resp.httpResponse;\n    if (req.operation === 'completeMultipartUpload' && httpResponse.body.toString().match('<Error>')) return false;else return httpResponse.statusCode < 300;\n  },\n\n  /**\n   * @return [Boolean] whether the error can be retried\n   * @api private\n   */\n  retryableError: function retryableError(error, request) {\n    if (request.operation === 'completeMultipartUpload' && error.statusCode === 200) {\n      return true;\n    } else if (error && error.code === 'RequestTimeout') {\n      return true;\n    } else {\n      var _super = AWS.Service.prototype.retryableError;\n      return _super.call(this, error, request);\n    }\n  },\n\n  /**\n   * Provides a specialized parser for getBucketLocation -- all other\n   * operations are parsed by the super class.\n   *\n   * @api private\n   */\n  extractData: function extractData(resp) {\n    var req = resp.request;\n\n    if (req.operation === 'getBucketLocation') {\n      var match = resp.httpResponse.body.toString().match(/>(.+)<\\/Location/);\n\n      if (match) {\n        delete resp.data['_'];\n        resp.data.LocationConstraint = match[1];\n      }\n    }\n  },\n\n  /**\n   * Extracts an error object from the http response.\n   *\n   * @api private\n   */\n  extractError: function extractError(resp) {\n    var codes = {\n      304: 'NotModified',\n      403: 'Forbidden',\n      400: 'BadRequest',\n      404: 'NotFound'\n    };\n    var code = resp.httpResponse.statusCode;\n    var body = resp.httpResponse.body;\n\n    if (codes[code] && body.length === 0) {\n      resp.error = AWS.util.error(new Error(), {\n        code: codes[resp.httpResponse.statusCode],\n        message: null\n      });\n    } else {\n      var data = new AWS.XML.Parser().parse(body.toString());\n      resp.error = AWS.util.error(new Error(), {\n        code: data.Code || code,\n        message: data.Message || null\n      });\n    }\n  },\n\n  /**\n   * Get a pre-signed URL for a given operation name.\n   *\n   * @note You must ensure that you have static or previously resolved\n   *   credentials if you call this method synchronously (with no callback),\n   *   otherwise it may not properly sign the request. If you cannot guarantee\n   *   this (you are using an asynchronous credential provider, i.e., EC2\n   *   IAM roles), you should always call this method with an asynchronous\n   *   callback.\n   * @param operation [String] the name of the operation to call\n   * @param params [map] parameters to pass to the operation. See the given\n   *   operation for the expected operation parameters. In addition, you can\n   *   also pass the \"Expires\" parameter to inform S3 how long the URL should\n   *   work for.\n   * @option params Expires [Integer] (900) the number of seconds to expire\n   *   the pre-signed URL operation in. Defaults to 15 minutes.\n   * @param callback [Function] if a callback is provided, this function will\n   *   pass the URL as the second parameter (after the error parameter) to\n   *   the callback function.\n   * @return [String] if called synchronously (with no callback), returns the\n   *   signed URL.\n   * @return [null] nothing is returned if a callback is provided.\n   * @example Pre-signing a getObject operation (synchronously)\n   *   var params = {Bucket: 'bucket', Key: 'key'};\n   *   var url = s3.getSignedUrl('getObject', params);\n   *   console.log('The URL is', url);\n   * @example Pre-signing a putObject (asynchronously)\n   *   var params = {Bucket: 'bucket', Key: 'key'};\n   *   s3.getSignedUrl('putObject', params, function (err, url) {\n   *     console.log('The URL is', url);\n   *   });\n   * @example Pre-signing a putObject operation with a specific payload\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};\n   *   var url = s3.getSignedUrl('putObject', params);\n   *   console.log('The URL is', url);\n   * @example Passing in a 1-minute expiry time for a pre-signed URL\n   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};\n   *   var url = s3.getSignedUrl('getObject', params);\n   *   console.log('The URL is', url); // expires in 60 seconds\n   */\n  getSignedUrl: function getSignedUrl(operation, params, callback) {\n    params = AWS.util.copy(params || {});\n    var expires = params.Expires || 900;\n    delete params.Expires; // we can't validate this\n\n    var request = this.makeRequest(operation, params);\n    return request.presign(expires, callback);\n  },\n\n  /**\n   * @api private\n   */\n  prepareSignedUrl: function prepareSignedUrl(request) {\n    request.removeListener('build', request.service.addContentType);\n\n    if (!request.params.Body) {\n      // no Content-MD5/SHA-256 if body is not provided\n      request.removeListener('build', request.service.computeContentMd5);\n      request.removeListener('build', request.service.computeSha256);\n    }\n  },\n  createBucket: function createBucket(params, callback) {\n    // When creating a bucket *outside* the classic region, the location\n    // constraint must be set for the bucket and it must match the endpoint.\n    // This chunk of code will set the location constraint param based\n    // on the region (when possible), but it will not override a passed-in\n    // location constraint.\n    if (!params) params = {};\n    var hostname = this.endpoint.hostname;\n\n    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {\n      params.CreateBucketConfiguration = {\n        LocationConstraint: this.config.region\n      };\n    }\n\n    return this.makeRequest('createBucket', params, callback);\n  }\n});","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/aws-sdk/lib/services/s3.js"],"names":["AWS","require","util","update","S3","prototype","validateService","config","region","setupRequestListeners","request","addListener","addContentType","populateURI","computeContentMd5","computeSha256","computeSseCustomerKeyMd5","removeListener","EventListeners","Core","VALIDATE_REGION","extractError","extractData","prepareSignedUrl","req","httpRequest","b","params","Bucket","service","pathStyleBucketName","endpoint","hostname","port","host","virtualHostedBucket","path","replace","RegExp","headers","contentType","isBrowser","body","match","charset","replaceFn","_","prefix","toUpperCase","computableChecksumOperations","putBucketCors","putBucketLifecycle","putBucketTagging","deleteObjects","willComputeChecksums","operation","computeChecksums","Buffer","isBuffer","rules","api","operations","input","members","getSignerClass","Signers","V4","ContentMD5","required","md5","crypto","sha256","arrayEach","header","key","md5header","base64","encode","value","bucketName","s3ForcePathStyle","dnsCompatibleBucketName","sslEnabled","domain","ipAddress","dots","escapePathParam","uriEscapePath","String","successfulResponse","resp","httpResponse","toString","statusCode","retryableError","error","code","_super","Service","call","data","LocationConstraint","codes","length","Error","message","XML","Parser","parse","Code","Message","getSignedUrl","callback","copy","expires","Expires","makeRequest","presign","Body","createBucket","globalEndpoint","CreateBucketConfiguration"],"mappings":"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","sourcesContent":["var AWS = require('../core');\n\nAWS.util.update(AWS.S3.prototype, {\n  /**\n   * @api private\n   */\n  validateService: function validateService() {\n    // default to us-east-1 when no region is provided\n    if (!this.config.region) this.config.region = 'us-east-1';\n  },\n\n  /**\n   * @api private\n   */\n  setupRequestListeners: function setupRequestListeners(request) {\n    request.addListener('build', this.addContentType);\n    request.addListener('build', this.populateURI);\n    request.addListener('build', this.computeContentMd5);\n    request.addListener('build', this.computeSha256);\n    request.addListener('build', this.computeSseCustomerKeyMd5);\n    request.removeListener('validate',\n      AWS.EventListeners.Core.VALIDATE_REGION);\n    request.addListener('extractError', this.extractError);\n    request.addListener('extractData', this.extractData);\n    request.addListener('beforePresign', this.prepareSignedUrl);\n  },\n\n  /**\n   * S3 prefers dns-compatible bucket names to be moved from the uri path\n   * to the hostname as a sub-domain.  This is not possible, even for dns-compat\n   * buckets when using SSL and the bucket name contains a dot ('.').  The\n   * ssl wildcard certificate is only 1-level deep.\n   *\n   * @api private\n   */\n  populateURI: function populateURI(req) {\n    var httpRequest = req.httpRequest;\n    var b = req.params.Bucket;\n\n    if (b) {\n      if (!req.service.pathStyleBucketName(b)) {\n        httpRequest.endpoint.hostname = b + '.' + httpRequest.endpoint.hostname;\n\n        var port = httpRequest.endpoint.port;\n        if (port !== 80 && port !== 443) {\n          httpRequest.endpoint.host = httpRequest.endpoint.hostname + ':' +\n            httpRequest.endpoint.port;\n        } else {\n          httpRequest.endpoint.host = httpRequest.endpoint.hostname;\n        }\n\n        httpRequest.virtualHostedBucket = b; // needed for signing the request\n        httpRequest.path = httpRequest.path.replace(new RegExp('/' + b), '');\n        if (httpRequest.path[0] !== '/') {\n          httpRequest.path = '/' + httpRequest.path;\n        }\n      }\n    }\n  },\n\n  /**\n   * Adds a default content type if none is supplied.\n   *\n   * @api private\n   */\n  addContentType: function addContentType(req) {\n    var httpRequest = req.httpRequest;\n    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type\n      httpRequest.headers['Content-Type'] = 'application/octet-stream';\n    }\n\n    var contentType = httpRequest.headers['Content-Type'];\n    if (AWS.util.isBrowser()) {\n      if (typeof httpRequest.body === 'string' && !contentType.match(/;\\s*charset=/)) {\n        var charset = '; charset=UTF-8';\n        httpRequest.headers['Content-Type'] += charset;\n      } else {\n        var replaceFn = function(_, prefix, charset) {\n          return prefix + charset.toUpperCase();\n        };\n\n        httpRequest.headers['Content-Type'] =\n          contentType.replace(/(;\\s*charset=)(.+)$/, replaceFn);\n      }\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computableChecksumOperations: {\n    putBucketCors: true,\n    putBucketLifecycle: true,\n    putBucketTagging: true,\n    deleteObjects: true\n  },\n\n  /**\n   * Checks whether checksums should be computed for the request.\n   * If the request requires checksums to be computed, this will always\n   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}\n   * is set.\n   *\n   * @param req [AWS.Request] the request to check against\n   * @return [Boolean] whether to compute checksums for a request.\n   * @api private\n   */\n  willComputeChecksums: function willComputeChecksums(req) {\n    if (this.computableChecksumOperations[req.operation]) return true;\n    if (!this.config.computeChecksums) return false;\n\n    // TODO: compute checksums for Stream objects\n    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) &&\n        typeof req.httpRequest.body !== 'string') {\n      return false;\n    }\n\n    var rules = req.service.api.operations[req.operation].input.members;\n\n    // V4 signer uses SHA256 signatures so only compute MD5 if it is required\n    if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;\n    }\n\n    if (rules.ContentMD5 && !req.params.ContentMD5) return true;\n  },\n\n  /**\n   * A listener that computes the Content-MD5 and sets it in the header.\n   * @see AWS.S3.willComputeChecksums\n   * @api private\n   */\n  computeContentMd5: function computeContentMd5(req) {\n    if (req.service.willComputeChecksums(req)) {\n      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');\n      req.httpRequest.headers['Content-MD5'] = md5;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computeSha256: function computeSha256(req) {\n    if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n      req.httpRequest.headers['X-Amz-Content-Sha256'] =\n        AWS.util.crypto.sha256(req.httpRequest.body || '', 'hex');\n    }\n  },\n\n  /**\n   * @api private\n   */\n  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {\n    var headers = [\n      'x-amz-server-side-encryption-customer-key',\n      'x-amz-copy-source-server-side-encryption-customer-key'\n    ];\n    AWS.util.arrayEach(headers, function(header) {\n      if (req.httpRequest.headers[header]) {\n        var key = req.httpRequest.headers[header];\n        var md5header = header + '-MD5';\n\n        req.httpRequest.headers[header] = AWS.util.base64.encode(key);\n        if (!req.httpRequest.headers[md5header]) {\n          var value = AWS.util.crypto.md5(key, 'base64');\n          req.httpRequest.headers[md5header] = AWS.util.base64.encode(value);\n        }\n\n      }\n    });\n  },\n\n  /**\n   * Returns true if the bucket name should be left in the URI path for\n   * a request to S3.  This function takes into account the current\n   * endpoint protocol (e.g. http or https).\n   *\n   * @api private\n   */\n  pathStyleBucketName: function pathStyleBucketName(bucketName) {\n    // user can force path style requests via the configuration\n    if (this.config.s3ForcePathStyle) return true;\n\n    if (this.dnsCompatibleBucketName(bucketName)) {\n      return (this.config.sslEnabled && bucketName.match(/\\./)) ? true : false;\n    } else {\n      return true; // not dns compatible names must always use path style\n    }\n  },\n\n  /**\n   * Returns true if the bucket name is DNS compatible.  Buckets created\n   * outside of the classic region MUST be DNS compatible.\n   *\n   * @api private\n   */\n  dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {\n    var b = bucketName;\n    var domain = new RegExp(/^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/);\n    var ipAddress = new RegExp(/(\\d+\\.){3}\\d+/);\n    var dots = new RegExp(/\\.\\./);\n    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;\n  },\n\n  /**\n   * S3 requires that path params not escape forward slashes.\n   *\n   * @api private\n   */\n  escapePathParam: function escapePathParam(value) {\n    return AWS.util.uriEscapePath(String(value));\n  },\n\n  /**\n   * @return [Boolean] whether response contains an error\n   * @api private\n   */\n  successfulResponse: function successfulResponse(resp) {\n    var req = resp.request;\n    var httpResponse = resp.httpResponse;\n    if (req.operation === 'completeMultipartUpload' &&\n        httpResponse.body.toString().match('<Error>'))\n      return false;\n    else\n      return httpResponse.statusCode < 300;\n  },\n\n  /**\n   * @return [Boolean] whether the error can be retried\n   * @api private\n   */\n  retryableError: function retryableError(error, request) {\n    if (request.operation === 'completeMultipartUpload' &&\n        error.statusCode === 200) {\n      return true;\n    } else if (error && error.code === 'RequestTimeout') {\n      return true;\n    } else {\n      var _super = AWS.Service.prototype.retryableError;\n      return _super.call(this, error, request);\n    }\n  },\n\n  /**\n   * Provides a specialized parser for getBucketLocation -- all other\n   * operations are parsed by the super class.\n   *\n   * @api private\n   */\n  extractData: function extractData(resp) {\n    var req = resp.request;\n    if (req.operation === 'getBucketLocation') {\n      var match = resp.httpResponse.body.toString().match(/>(.+)<\\/Location/);\n      if (match) {\n        delete resp.data['_'];\n        resp.data.LocationConstraint = match[1];\n      }\n    }\n  },\n\n  /**\n   * Extracts an error object from the http response.\n   *\n   * @api private\n   */\n  extractError: function extractError(resp) {\n    var codes = {\n      304: 'NotModified',\n      403: 'Forbidden',\n      400: 'BadRequest',\n      404: 'NotFound'\n    };\n\n    var code = resp.httpResponse.statusCode;\n    var body = resp.httpResponse.body;\n    if (codes[code] && body.length === 0) {\n      resp.error = AWS.util.error(new Error(), {\n        code: codes[resp.httpResponse.statusCode],\n        message: null\n      });\n    } else {\n      var data = new AWS.XML.Parser().parse(body.toString());\n      resp.error = AWS.util.error(new Error(), {\n        code: data.Code || code,\n        message: data.Message || null\n      });\n    }\n  },\n\n  /**\n   * Get a pre-signed URL for a given operation name.\n   *\n   * @note You must ensure that you have static or previously resolved\n   *   credentials if you call this method synchronously (with no callback),\n   *   otherwise it may not properly sign the request. If you cannot guarantee\n   *   this (you are using an asynchronous credential provider, i.e., EC2\n   *   IAM roles), you should always call this method with an asynchronous\n   *   callback.\n   * @param operation [String] the name of the operation to call\n   * @param params [map] parameters to pass to the operation. See the given\n   *   operation for the expected operation parameters. In addition, you can\n   *   also pass the \"Expires\" parameter to inform S3 how long the URL should\n   *   work for.\n   * @option params Expires [Integer] (900) the number of seconds to expire\n   *   the pre-signed URL operation in. Defaults to 15 minutes.\n   * @param callback [Function] if a callback is provided, this function will\n   *   pass the URL as the second parameter (after the error parameter) to\n   *   the callback function.\n   * @return [String] if called synchronously (with no callback), returns the\n   *   signed URL.\n   * @return [null] nothing is returned if a callback is provided.\n   * @example Pre-signing a getObject operation (synchronously)\n   *   var params = {Bucket: 'bucket', Key: 'key'};\n   *   var url = s3.getSignedUrl('getObject', params);\n   *   console.log('The URL is', url);\n   * @example Pre-signing a putObject (asynchronously)\n   *   var params = {Bucket: 'bucket', Key: 'key'};\n   *   s3.getSignedUrl('putObject', params, function (err, url) {\n   *     console.log('The URL is', url);\n   *   });\n   * @example Pre-signing a putObject operation with a specific payload\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};\n   *   var url = s3.getSignedUrl('putObject', params);\n   *   console.log('The URL is', url);\n   * @example Passing in a 1-minute expiry time for a pre-signed URL\n   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};\n   *   var url = s3.getSignedUrl('getObject', params);\n   *   console.log('The URL is', url); // expires in 60 seconds\n   */\n  getSignedUrl: function getSignedUrl(operation, params, callback) {\n    params = AWS.util.copy(params || {});\n    var expires = params.Expires || 900;\n    delete params.Expires; // we can't validate this\n    var request = this.makeRequest(operation, params);\n    return request.presign(expires, callback);\n  },\n\n  /**\n   * @api private\n   */\n  prepareSignedUrl: function prepareSignedUrl(request) {\n    request.removeListener('build', request.service.addContentType);\n    if (!request.params.Body) {\n      // no Content-MD5/SHA-256 if body is not provided\n      request.removeListener('build', request.service.computeContentMd5);\n      request.removeListener('build', request.service.computeSha256);\n    }\n  },\n\n  createBucket: function createBucket(params, callback) {\n    // When creating a bucket *outside* the classic region, the location\n    // constraint must be set for the bucket and it must match the endpoint.\n    // This chunk of code will set the location constraint param based\n    // on the region (when possible), but it will not override a passed-in\n    // location constraint.\n    if (!params) params = {};\n    var hostname = this.endpoint.hostname;\n    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {\n      params.CreateBucketConfiguration = { LocationConstraint: this.config.region };\n    }\n    return this.makeRequest('createBucket', params, callback);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}
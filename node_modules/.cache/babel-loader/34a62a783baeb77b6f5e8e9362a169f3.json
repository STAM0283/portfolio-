{"ast":null,"code":"var AWS = require('./core');\n\nvar domain = AWS.util.nodeRequire('domain');\n/**\n * @!method on(eventName, callback)\n *   Registers an event listener callback for the event given by `eventName`.\n *   Parameters passed to the callback function depend on the individual event\n *   being triggered. See the event documentation for those parameters.\n *\n *   @param eventName [String] the event name to register the listener for\n *   @param callback [Function] the listener callback function\n *   @return [AWS.SequentialExecutor] the same object for chaining\n */\n\nAWS.SequentialExecutor = AWS.util.inherit({\n  constructor: function SequentialExecutor() {\n    this.domain = domain && domain.active;\n    this._events = {};\n  },\n\n  /**\n   * @api private\n   */\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n  on: function on(eventName, listener) {\n    if (this._events[eventName]) {\n      this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  onAsync: function onAsync(eventName, listener) {\n    listener._isAsync = true;\n    return this.on(eventName, listener);\n  },\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n\n    return this;\n  },\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = this.unhandledErrorCallback;\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n\n  /**\n   * @api private\n   */\n  callListeners: function callListeners(listeners, args, doneCallback) {\n    if (listeners.length === 0) {\n      doneCallback.call(this);\n      return;\n    }\n\n    var self = this,\n        listener = listeners.shift();\n\n    if (listener._isAsync) {\n      // asynchronous listener\n      var callNextListener = function (err) {\n        if (err) {\n          doneCallback.call(self, err);\n        } else {\n          self.callListeners(listeners, args, doneCallback);\n        }\n      };\n\n      listener.apply(self, args.concat([callNextListener]));\n    } else {\n      // synchronous listener\n      try {\n        listener.apply(self, args);\n        self.callListeners(listeners, args, doneCallback);\n      } catch (err) {\n        doneCallback.call(self, err);\n      }\n    }\n  },\n\n  /**\n   * Adds or copies a set of listeners from another list of\n   * listeners or SequentialExecutor object.\n   *\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\n   *   a list of events and callbacks, or an event emitter object\n   *   containing listeners to add to this emitter object.\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\n   * @example Adding listeners from a map of listeners\n   *   emitter.addListeners({\n   *     event1: [function() { ... }, function() { ... }],\n   *     event2: [function() { ... }]\n   *   });\n   *   emitter.emit('event1'); // emitter has event1\n   *   emitter.emit('event2'); // emitter has event2\n   * @example Adding listeners from another emitter object\n   *   var emitter1 = new AWS.SequentialExecutor();\n   *   emitter1.on('event1', function() { ... });\n   *   emitter1.on('event2', function() { ... });\n   *   var emitter2 = new AWS.SequentialExecutor();\n   *   emitter2.addListeners(emitter1);\n   *   emitter2.emit('event1'); // emitter2 has event1\n   *   emitter2.emit('event2'); // emitter2 has event2\n   */\n  addListeners: function addListeners(listeners) {\n    var self = this; // extract listeners if parameter is an SequentialExecutor object\n\n    if (listeners._events) listeners = listeners._events;\n    AWS.util.each(listeners, function (event, callbacks) {\n      if (typeof callbacks === 'function') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function (callback) {\n        self.on(event, callback);\n      });\n    });\n    return self;\n  },\n\n  /**\n   * Registers an event with {on} and saves the callback handle function\n   * as a property on the emitter object using a given `name`.\n   *\n   * @param name [String] the property name to set on this object containing\n   *   the callback function handle so that the listener can be removed in\n   *   the future.\n   * @param (see on)\n   * @return (see on)\n   * @example Adding a named listener DATA_CALLBACK\n   *   var listener = function() { doSomething(); };\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\n   *\n   *   // the following prints: true\n   *   console.log(emitter.DATA_CALLBACK == listener);\n   */\n  addNamedListener: function addNamedListener(name, eventName, callback) {\n    this[name] = callback;\n    this.addListener(eventName, callback);\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback);\n  },\n\n  /**\n   * Helper method to add a set of named listeners using\n   * {addNamedListener}. The callback contains a parameter\n   * with a handle to the `addNamedListener` method.\n   *\n   * @callback callback function(add)\n   *   The callback function is called immediately in order to provide\n   *   the `add` function to the block. This simplifies the addition of\n   *   a large group of named listeners.\n   *   @param add [Function] the {addNamedListener} function to call\n   *     when registering listeners.\n   * @example Adding a set of named listeners\n   *   emitter.addNamedListeners(function(add) {\n   *     add('DATA_CALLBACK', 'data', function() { ... });\n   *     add('OTHER', 'otherEvent', function() { ... });\n   *     add('LAST', 'lastEvent', function() { ... });\n   *   });\n   *\n   *   // these properties are now set:\n   *   emitter.DATA_CALLBACK;\n   *   emitter.OTHER;\n   *   emitter.LAST;\n   */\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(function () {\n      self.addNamedListener.apply(self, arguments);\n    }, function () {\n      self.addNamedAsyncListener.apply(self, arguments);\n    });\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  unhandledErrorCallback: function unhandledErrorCallback(err) {\n    if (err) {\n      if (domain && this.domain instanceof domain.Domain) {\n        err.domainEmitter = this;\n        err.domain = this.domain;\n        err.domainThrown = false;\n        this.domain.emit('error', err);\n      } else {\n        throw err;\n      }\n    }\n  }\n});\n/**\n * {on} is the prefered method.\n * @api private\n */\n\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\nmodule.exports = AWS.SequentialExecutor;","map":{"version":3,"sources":["/home/wilder/Documents/portfolio/node_modules/aws-sdk/lib/sequential_executor.js"],"names":["AWS","require","domain","util","nodeRequire","SequentialExecutor","inherit","constructor","active","_events","listeners","eventName","slice","on","listener","push","onAsync","_isAsync","removeListener","length","position","i","splice","removeAllListeners","emit","eventArgs","doneCallback","unhandledErrorCallback","count","callListeners","args","call","self","shift","callNextListener","err","apply","concat","addListeners","each","event","callbacks","arrayEach","callback","addNamedListener","name","addListener","addNamedAsyncListener","addNamedListeners","arguments","Domain","domainEmitter","domainThrown","prototype","module","exports"],"mappings":"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","sourcesContent":["var AWS = require('./core');\nvar domain = AWS.util.nodeRequire('domain');\n\n/**\n * @!method on(eventName, callback)\n *   Registers an event listener callback for the event given by `eventName`.\n *   Parameters passed to the callback function depend on the individual event\n *   being triggered. See the event documentation for those parameters.\n *\n *   @param eventName [String] the event name to register the listener for\n *   @param callback [Function] the listener callback function\n *   @return [AWS.SequentialExecutor] the same object for chaining\n */\nAWS.SequentialExecutor = AWS.util.inherit({\n\n  constructor: function SequentialExecutor() {\n    this.domain = domain && domain.active;\n    this._events = {};\n  },\n\n  /**\n   * @api private\n   */\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n\n  on: function on(eventName, listener) {\n    if (this._events[eventName]) {\n      this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  onAsync: function onAsync(eventName, listener) {\n    listener._isAsync = true;\n    return this.on(eventName, listener);\n  },\n\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n    return this;\n  },\n\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = this.unhandledErrorCallback;\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n\n  /**\n   * @api private\n   */\n  callListeners: function callListeners(listeners, args, doneCallback) {\n    if (listeners.length === 0) {\n      doneCallback.call(this);\n      return;\n    }\n\n    var self = this, listener = listeners.shift();\n    if (listener._isAsync) { // asynchronous listener\n      var callNextListener = function(err) {\n        if (err) {\n          doneCallback.call(self, err);\n        } else {\n          self.callListeners(listeners, args, doneCallback);\n        }\n      };\n      listener.apply(self, args.concat([callNextListener]));\n    } else { // synchronous listener\n      try {\n        listener.apply(self, args);\n        self.callListeners(listeners, args, doneCallback);\n      } catch (err) {\n        doneCallback.call(self, err);\n      }\n    }\n  },\n\n  /**\n   * Adds or copies a set of listeners from another list of\n   * listeners or SequentialExecutor object.\n   *\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\n   *   a list of events and callbacks, or an event emitter object\n   *   containing listeners to add to this emitter object.\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\n   * @example Adding listeners from a map of listeners\n   *   emitter.addListeners({\n   *     event1: [function() { ... }, function() { ... }],\n   *     event2: [function() { ... }]\n   *   });\n   *   emitter.emit('event1'); // emitter has event1\n   *   emitter.emit('event2'); // emitter has event2\n   * @example Adding listeners from another emitter object\n   *   var emitter1 = new AWS.SequentialExecutor();\n   *   emitter1.on('event1', function() { ... });\n   *   emitter1.on('event2', function() { ... });\n   *   var emitter2 = new AWS.SequentialExecutor();\n   *   emitter2.addListeners(emitter1);\n   *   emitter2.emit('event1'); // emitter2 has event1\n   *   emitter2.emit('event2'); // emitter2 has event2\n   */\n  addListeners: function addListeners(listeners) {\n    var self = this;\n\n    // extract listeners if parameter is an SequentialExecutor object\n    if (listeners._events) listeners = listeners._events;\n\n    AWS.util.each(listeners, function(event, callbacks) {\n      if (typeof callbacks === 'function') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function(callback) {\n        self.on(event, callback);\n      });\n    });\n\n    return self;\n  },\n\n  /**\n   * Registers an event with {on} and saves the callback handle function\n   * as a property on the emitter object using a given `name`.\n   *\n   * @param name [String] the property name to set on this object containing\n   *   the callback function handle so that the listener can be removed in\n   *   the future.\n   * @param (see on)\n   * @return (see on)\n   * @example Adding a named listener DATA_CALLBACK\n   *   var listener = function() { doSomething(); };\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\n   *\n   *   // the following prints: true\n   *   console.log(emitter.DATA_CALLBACK == listener);\n   */\n  addNamedListener: function addNamedListener(name, eventName, callback) {\n    this[name] = callback;\n    this.addListener(eventName, callback);\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback);\n  },\n\n  /**\n   * Helper method to add a set of named listeners using\n   * {addNamedListener}. The callback contains a parameter\n   * with a handle to the `addNamedListener` method.\n   *\n   * @callback callback function(add)\n   *   The callback function is called immediately in order to provide\n   *   the `add` function to the block. This simplifies the addition of\n   *   a large group of named listeners.\n   *   @param add [Function] the {addNamedListener} function to call\n   *     when registering listeners.\n   * @example Adding a set of named listeners\n   *   emitter.addNamedListeners(function(add) {\n   *     add('DATA_CALLBACK', 'data', function() { ... });\n   *     add('OTHER', 'otherEvent', function() { ... });\n   *     add('LAST', 'lastEvent', function() { ... });\n   *   });\n   *\n   *   // these properties are now set:\n   *   emitter.DATA_CALLBACK;\n   *   emitter.OTHER;\n   *   emitter.LAST;\n   */\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(\n      function() {\n        self.addNamedListener.apply(self, arguments);\n      },\n      function() {\n        self.addNamedAsyncListener.apply(self, arguments);\n      }\n    );\n    return this;\n  },\n\n  /**\n   * @api private\n   */\n  unhandledErrorCallback: function unhandledErrorCallback(err) {\n    if (err) {\n      if (domain && this.domain instanceof domain.Domain) {\n        err.domainEmitter = this;\n        err.domain = this.domain;\n        err.domainThrown = false;\n        this.domain.emit('error', err);\n      } else {\n        throw err;\n      }\n    }\n  }\n});\n\n/**\n * {on} is the prefered method.\n * @api private\n */\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n\nmodule.exports = AWS.SequentialExecutor;\n"]},"metadata":{},"sourceType":"script"}